<html>
<head>
<title>OPLnotes</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#dddddd" text="#000000" leftmargin="0" topmargin="0">
<!-- BEGIN WAYBACK TOOLBAR INSERT -->

<script type="text/javascript" src="http://staticweb.archive.org/js/disclaim-element.js" ></script>
<script type="text/javascript" src="http://staticweb.archive.org/js/graph-calc.js" ></script>
<script type="text/javascript" src="http://staticweb.archive.org/jflot/jquery.min.js" ></script>
<script type="text/javascript">
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1356998399999;
var wbPrefix = "http://web.archive.org/web/";
var wbCurrentUrl = "http:\/\/opldev.broeze.eu\/dpNotes\/";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth=450;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "23";
var displayMonth = "Mar";
var displayYear = "2008";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]>
</script>

<style type="text/css">body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}</style>
<div id="wm-ipp" style="display:none; position:relative;padding:0 5px;min-height:70px;min-width:800px; z-index:9000;">
<div id="wm-ipp-inside" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(http://staticweb.archive.org/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:'Lucida Grande','Arial',sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr>
   <td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="http://wayback.archive.org/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="http://staticweb.archive.org/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"/></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr>
       <td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="http://wayback.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://opldev.broeze.eu/dpNotes/" style="width:400px;font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;" onfocus="javascript:this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20080323085741" /><input type="submit" value="Go" style="font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;margin-left:5px;" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:'Helvetica','Lucida Grande','Arial',sans-serif;"><tbody>
			
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr style="width:110px;height:16px;font-size:10px!important;">
           	<td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="http://web.archive.org/web/20080121123426/http://opldev.broeze.eu/dpNotes/" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="21 Jan 2008"><strong>JAN</strong></a>
		                
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 8:57:41 Mar 23, 2008">MAR</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       Apr
                       
               </td>
           </tr>

           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr>
               <td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="http://web.archive.org/web/20080321194038/http://opldev.broeze.eu/dpNotes/" title="19:40:38 Mar 21, 2008" style="background-color:transparent;border:none;"><img src="http://staticweb.archive.org/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
		                
               </td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 8:57:41 Mar 23, 2008">23</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
                       <img src="http://staticweb.archive.org/images/toolbar/wm_tb_nxt_off.png" alt="Next capture" width="14" height="16" border="0"/>
                       
			    </td>
           </tr>

           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr style="width:110px;height:13px;font-size:9px!important;">
				<td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2007
                       
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 8:57:41 Mar 23, 2008">2008</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2009
                       
				</td>
           </tr>
           </tbody></table>
       </td>

       </tr>
       <tr>
       <td style="vertical-align:middle;padding:0!important;">
           <a href="http://wayback.archive.org/web/20080323085741*/http://opldev.broeze.eu/dpNotes/" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>6 captures</strong></a>
           <div style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">20 Nov 07 - 23 Mar 08</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:450px;height:27px;" href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:450px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;"
				onmouseover="showTrackers('inline');" 
				onmouseout="showTrackers('none');"
				onmousemove="trackMouseMove(event,this)"
				alt="sparklines"
				width="450"
				height="27"
				border="0"
				src="http://wayback.archive.org/web/jsp/graph.jsp?graphdata=450_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000000_2007:-1:000000000020_2008:2:202000000000_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000000000000_2012:-1:000000000000"></img>
			<img id="wbMouseTrackYearImg" 
				style="display:none; position:absolute; z-index:9010;"
				width="25" 
				height="27"
				border="0"
				src="http://staticweb.archive.org/images/toolbar/transp-yellow-pixel.png"></img>
			<img id="wbMouseTrackMonthImg"
				style="display:none; position:absolute; z-index:9011; " 
				width="2"
				height="27" 
				border="0"
				src="http://staticweb.archive.org/images/toolbar/transp-red-pixel.png"></img>
       </div>
		</a>

       </td>
       </tr></tbody></table>
   </td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById('wm-ipp').style.display='none';" style="display:block;padding-right:18px;background:url(http://staticweb.archive.org/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(http://staticweb.archive.org/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>

</div>
</div>
<script type="text/javascript">
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
</script>
<!-- END WAYBACK TOOLBAR INSERT -->

<table border="0" cellpadding="12" cellspacing="2" name="MainBody" width="800" height="0" bordercolor="#000000">
  <tr bgcolor="#dddddd"> 
    <td valign="top"><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes"><img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/dpgrey.jpg" width="95" height="72" border="0"></a></td>
    <td valign="middle" bgcolor="#dddddd"><font face="Arial, Helvetica, sans-serif"><b><font color="#000080" face="Arial" size="-1">dpNotes are a collection of - hopefully - useful ideas for the furtherance of OPL programming. In dpNotes we focus primarily on Symbian OS v6 (ER6) and later, though some of it was around already at v5 (ER5) and even OPL16 times.<p>dpNotes were written by Martin Harnevie. If you have any comments or ideas please mail them to Martin at <img align="absbottom" src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/MartinAtSymbian.gif"></font></b></font></td>
  </tr>
  <tr bgcolor="#dddddd"> 
    <td width="97" height="40" bgcolor="#cccccc"> 
      <p><font color="#800000" size="+1"><i><b><img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/OPL.gif" width="53" height="53"></b></i></font></p>    </td>
    <td width="700" height="40" bgcolor="#cccccc"> 
      <div align="left"><font size="+1" color="#000066"><b><font face="Arial, Helvetica, sans-serif">dpNotes</font></b></font></div>    </td>
  </tr>
  <tr> 
    <td width="97" height="40" valign="top" bgcolor="#FFFFCC"> 
      <p><font face="Arial, Helvetica, sans-serif"><b> <font color="#000080" size="-1">Index</font><br>
        </b></font></p>    </td>
    <td width="700" height="40"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0001">dpNote 
        0001</a></b></font><font face="Arial, Helvetica, sans-serif"><b> - </b></font><font size="-1" face="Arial, Helvetica, sans-serif"><b><font color="#000080">Finding 
        out the number of images in an MBM file</font></b></font><font face="Arial, Helvetica, sans-serif"><b><br>
        </b></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0002">dpNote 
        0002</a></b></font><font size="-1" face="Arial, Helvetica, sans-serif"><b><b> - </b></b></font><font face="Arial, Helvetica, sans-serif" color="#000080">Using 
        the Nokia 9200 Series Communicator system fonts</font><font face="Arial, Helvetica, sans-serif"><br>
        <font color="#000080" size="-1"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0003">dpNote 
        0003</a></b></font></font><font size="-1" face="Arial, Helvetica, sans-serif"><b><b><b> 
        - </b></b><font color="#000080">Getting 
        the path to the location of an OPL application</font></b></font><font face="Arial, Helvetica, sans-serif" color="#000080"><br>
        </font><font size="-1" face="Arial, Helvetica, sans-serif"><b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0004">dpNote 
        0004</a></b></font><b><b> - </b></b><font color="#000080">IOSEEK 
        - documented and undocumented features</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0005">dpNote 
        0005</a></b></font><b> - </b></b></font><font face="Arial, Helvetica, sans-serif" color="#000080">Calculating 
        UID checksum</font><font face="Arial, Helvetica, sans-serif"><br>
        <font color="#000080" size="-1"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0006">dpNote 
        0006</a></b></font></font><font size="-1" face="Arial, Helvetica, sans-serif"><b><b> - </b></b></font><font face="Arial, Helvetica, sans-serif" color="#000080">Handling 
        of simple stacks </font><font face="Arial, Helvetica, sans-serif"><br>
        <font color="#000080" size="-1"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0007">dpNote 
        0007</a></b></font></font><font size="-1" face="Arial, Helvetica, sans-serif"><b><b><b> 
        - </b></b></b></font> <font size="-1" face="Arial, Helvetica, sans-serif"><b><font color="#000080">Multi-dimensional 
        arrays </font></b></font><font face="Arial, Helvetica, sans-serif" color="#000080"><br>
        </font><font size="-1" face="Arial, Helvetica, sans-serif"><b><b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0008">dpNote 
        0008</a></b></font><b> - </b></b></b></font></b></font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><strong>Stack of buffers with configurable size</strong></font><font size="-1"><b><font size="-1" face="Arial, Helvetica, sans-serif"><b><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0009">dpNote 
        0009</a></b></font><b><b> - </b><font color="#000080">Getting 
        the serial (IMEI) number of a Nokia 9200 Series Communicator</font></b><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0010">dpNote 
        0010</a></b></font><b><b><b> 
        - </b></b><font color="#000080">Making 
        the v6/S80 WINS Emulator more programmer friendly for OPL development</font></b><font color="#000080"><b><br>
        </b></font><b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0011">dpNote 
        0011</a></b></font><b> - 
        <b><b><font color="#000080">Showing 
        the amount of free memory</font></b></b><br>
        </b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0012">dpNote 
        0012</a></b></font><b><b> - <b><font color="#000080">Naming 
        conventions</font></b></b></b><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0013">dpNote 
        0013</a></b></font><b><b><b> 
        - </b></b></b><font color="#000080">Conversion 
        between large hexadecimal and decimal numbers<br>
        </font><b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0014">dpNote 
        0014</a></b></font><b><b> - </b></b><font color="#000080">Useful POKEs and PEEKs</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0015">dpNote 
        0015</a></b></font><b> - </b></b><font color="#000080">Endianism</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0016">dpNote 
        0016</a></b></font><b><b> - </b></b><font color="#000080">Toolbar 
        buttons with text only</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0017">dpNote 
        0017</a></b></font><b><b><b> 
        - </b></b></b> <font color="#000080"> 
        dpToolbar - a better Toolbar for Psion Teklogix netBook and Psion Series 
        7<br>
        </font><b><b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0018">dpNote 
        0018</a></b></font><b> - </b></b><font color="#000080">Loading 
        a complete file into a buffer</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0019">dpNote 
        0019</a></b></font><b><b> - </b></b></b><font color="#000080"><b>Converting 
        long text buffers between Unicode and Ascii</b></font><b><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0020">dpNote 
        0020</a></b></font><b><b><b> 
        - </b></b></b> </b></b><font color="#000080">LOC 
        function which gives correct answer for control and Unicode characters</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0021">dpNote 
        0021</a></b></font><b> - </b></b></font><font size="-1"><b><font color="#000080" size="-1" face="Arial, Helvetica, sans-serif"><b>Character conversions</b></font></b></font><font size="-1" face="Arial, Helvetica, sans-serif"><b><b><br>
        </b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0022">dpNote 
        0022</a></b></font><b><b> - </b></b></b><font size="-1"><b><b><font color="#000080">Converting between Unicode and  SCSU </font></b></b></font><b><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0023">dpNote 
        0023</a></b></font><b><b><b> 
        - </b></b></b><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Clipboard - accurate copying and pasting of text in ER6 and ER7</font></b></font><font color="#000080"><br>
        </font><b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0024">dpNote 
        0024</a></b></font><b><b> - </b></b></b></b><font size="-1"><b><b><b><font color="#000080">Adding a bitmap to an MBM file </font></b></b></b></font><b><b><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0025">dpNote 
        0025</a></b></font><b> - </b></b><font color="#000080" size="-1" face="Arial, Helvetica, sans-serif">Useful IO functions and wrappers</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0025">dpNote 
        0026</a></b></font><b><b> - <font color="#000080">Predictable Pause </font></b></b><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0027">dpNote 
        0027</a></b></font><b><b><b> 
        - </b></b></b> <font color="#000080"> 
        Launching an application from OPL and wait until it finishes before returning<br>
        </font><b><b><font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0028">dpNote 
        0028</a></b></font></b> - <font color="#000080">Asynchronous 
        event loop with inactivity timer</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0029">dpNote 
        0029</a></b></font> - <font color="#000080">Key 
        event codes for Series 60 phones</font><br>
        <font color="#000080"><b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0030">dpNote 
        0030</a></b></font> </b> </b></font><font face="Arial, Helvetica, sans-serif" color="#000080">- 
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Returning more than one value</font></b></font><font face="Arial, Helvetica, sans-serif" color="#000080"><br>
        <br>
        </font></b></font><font size="-1"><font face="Arial, Helvetica, sans-serif" color="#000080"><i><b>Note:</b></i> For ease of reading, we are using</font><font face="Courier New, Courier, mono" color="#000080"><font color="#000000"> 
        // </font></font><font face="Arial, Helvetica, sans-serif" color="#000080">comments 
        in lieu of</font><font size="-1"><font face="Courier New, Courier, mono" color="#000000"> 
        REM </font></font><font face="Arial, Helvetica, sans-serif" color="#000080">comments. 
        We only use the latter to inactivate code, not to add comments code. If 
        you try to compile with </font><font size="-1"><font face="Courier New, Courier, mono" color="#000080"><font color="#000000"> 
        //<font face="Arial, Helvetica, sans-serif" color="#000080"> co</font></font></font><font face="Arial, Helvetica, sans-serif" color="#000080">mments 
        you will of course get an error, but</font></font><font face="Arial, Helvetica, sans-serif" color="#000080"> 
        you can easily change to</font><font face="Courier New, Courier, mono" color="#000000"> 
        // </font><font face="Arial, Helvetica, sans-serif" color="#000080">comments 
    using Find/Replace All. </font></font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"> 
      <p><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0001"></a>dpNote 
        0001</b><br>
        <br>
        2 July 2002</font><font size="-1"><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">All OPL versions </font></font></p>    </td>
    <td width="700"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Finding 
        out the number of images in an MBM file</font></b><br>
        <br>
      </font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">This 
        procedure is quite useful when the number of images in an MBM file is 
        unknown. <br>
      Usage: </font><font face="Courier New, Courier, mono" size="-1">NumberOfImages&amp;=IoMbmImages&amp;:(aMbmFileName$)<br>
      <br>
      </font><font face="Courier New, Courier, mono" size="-1">CONST KMbmFileImageCounterOffset&amp;=&amp;00000010<br>
      CONST KLongSize&amp;=4<br>
        <br>
        PROC IoMbmImages&amp;:(aMbmFileName$)<br>
        LOCAL IoStatus%,hMbm%,IoMode%,Offset&amp;,NoOfImages&amp;<br>
        // open the image file<br>
        IoMode%=KIoModeOpen% OR KIoFormatBinary% OR KIoAccessRandom% OR KIoAccessShare%<br>
        IoStatus%=IOOPEN(hMbm%,aMbmFileName$,IoMode%)<br>
        IF IoStatus%&lt;0<br>
&nbsp;&nbsp;RAISE KErrNotExists%<br>
        ENDIF<br>
        // move to the position of the offset address of the image counter<br>
        Offset&amp;=KMbmFileImageCounterOffset&amp;<br>
        IOSEEK(hMbm%,1,Offset&amp;)<br>
        // read the position of the image counter<br>
        IOREAD(hMbm%,ADDR(Offset&amp;),KLongSize&amp;)<br>
        // move to the position of the image counter<br>
        IOSEEK(hMbm%,1,Offset&amp;)<br>
        // read the image counter<br>
        IOREAD(hMbm%,ADDR(NoOfImages&amp;),KLongSize&amp;)<br>
        // close the image file<br>
        IOCLOSE(hMbm%)<br>
        // return number of images in file<br>
        RETURN NoOfImages&amp;<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0002"></a>dpNote 
      0002</b><br>
      <br>
      5 July 2002</font><font size="-1"><br>
      <font face="Arial, Helvetica, sans-serif" color="#000080"><br>
      v6 Series 80 R1 </font></font></td>
    <td width="700"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Using 
        the Nokia 9200 Series Communicator system fonts</font></b><br>
        <br>
        <font color="#000080" face="Arial, Helvetica, sans-serif">The </font></font><font face="Courier New, Courier, mono" size="-1">Const.oph</font><font color="#000080" face="Arial, Helvetica, sans-serif" size="-1"> 
        file for Symbian OS v6.0 does not include the font UIDs for the Nokia 
        9200 Series Communicator. You could add the following constants to your 
        </font><font face="Arial, Helvetica, sans-serif" size="-1"> <font face="Courier New, Courier, mono"> 
        Const.oph</font></font><font color="#000080" face="Arial, Helvetica, sans-serif" size="-1"> 
        file to address this:</font><font size="-1"><br>
        <br>
        <font face="Courier New, Courier, mono">CONST KFontLindaBold16&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457209 
        // &amp;100054F9<br>
        CONST KFontLindaBold18&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457210<br>
        CONST KFontLindaBold20&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457211 
        // in CBA titles for 9210<br>
        CONST KFontLindaBold22&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457212<br>
        CONST KFontLindaBold24&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457213<br>
        CONST KFontLindaBold29&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457214<br>
        CONST KFontLindaBoldItalic20&amp;= &nbsp;&nbsp;268457215<br>
        CONST KFontLindaItalic20&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457216<br>
        CONST KFontLindaNarrow20&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457217<br>
        CONST KFontLindaNarrow24&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457218<br>
        CONST KFontLindaNarrow29&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457219<br>
        CONST KFontLindaNormal18&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457220<br>
        CONST KFontLindaNormal20&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457221 
        // in gIPRINT for 9210<br>
        CONST KFontLindaNormal24&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457222<br>
        CONST KFontLindaNormal29&amp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;268457223&nbsp;</font></font><font face="Courier New, Courier, mono" size="-1">// 
        &amp;10005507</font><font size="-1"><br>
        <br>
        <font face="Courier New, Courier, mono">CONST KFontTerminalNormal8&amp;=&nbsp;&nbsp; 
        &nbsp;&nbsp;268437778&nbsp;// &amp;10000912, same in ER5<br>
        CONST KFontTerminalZoomed15&amp;= &nbsp;&nbsp;&nbsp;268437779 // &amp;10000913</font></font><font face="Courier New, Courier, mono" size="-1">, 
        same in ER5</font><font size="-1"><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">The fonts are 
        now selectable with </font></font><font face="Courier New, Courier, mono" size="-1">gFONT</font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        as normal.<br>
        <br>
        The designations given are now taken from the 9210 screen layout document. 
        They are slightly modified to comply with OPL coding standards.
        <br>
        <br>
        The </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">KFontLindaBold20&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        UID is particularly useful if you wish to have a consistent font on your 
        CBA titles.</font></p>
      <p><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">And 
        the </font><font face="Courier New, Courier, mono" size="-1">KFontLindaNormal20&amp;</font> 
        <font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">UID 
        is useful if you wish to create variants of </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">gIPRINT</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        and </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">ALERT</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        messages.</font> <font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">By 
        the way, the green frame has the RGB value</font> <font face="Courier New, Courier, mono" size="-1">KRgbMessageBorderGreen&amp;=&amp;008800</font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">.</font><font size="-1"><br>
        </font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><p><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0003"></a>dpNote 
      0003<br>
      <br>
      </b>15 July 2002</font><font size="-1"><br>
        <br>
        <font color="#000080" face="Arial, Helvetica, sans-serif">All OPL versions</font></font></p>      </td>
    <td width="700"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Getting 
        the path to the location of an OPL application</font></b><br>
        <br>
      </font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">This 
        is a routine used in every OPL application we've developed. We have seen 
        so many different ways of doing the same thing, but we find this method 
        the most universal.<br>
        <br>
        Usage, and one of the first things you do in the application:<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Location$=</font></font><font face="Courier New, Courier, mono" size="-1">Path$:</font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><br>
        <br>
        </font><font face="Courier New, Courier, mono" size="-1">CONST KMaxFilenameLen%=255<br>
        CONST KCmdAppName%=1<br>
        CONST KParseFilenameOffset%=4</font><font size="-1"><br>
        <font face="Courier New, Courier, mono"><br>
        </font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">The 
        constants above should normally be included in Const.oph.</font><font face="Courier New, Courier, mono" size="-1"><br>
        <br>
        PROC Path$:<br>
        LOCAL Path$(KMaxFilenameLen%),Offset%(6)<br>
        Path$=PARSE$(CMD$(KCmdAppName%),&quot;&quot;,Offset%())<br>
        Path$=LEFT$(Path$,Offset%(KParseFilenameOffset%)-1)<br>
        RETURN Path$<br>
        ENDP<br>
        <br>
        </font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0004"></a>dpNote 
      0004<br>
      <br>
      </b>15 July 2002</font><font size="-1"><br>
      <br>
      <font color="#000080" face="Arial, Helvetica, sans-serif">All OPL versions </font>
      <br>
      </font></td>
    <td width="700"><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">IOSEEK 
      - documented and undocumented features<br>
      <br>
      </font></b><font face="Courier New, Courier, mono">IOSEEK</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      has two more uses than the OPL manuals, for instance the OPL Guide &amp; 
      Reference (Release 036 for ER5),<br>
      usually mention. Modes 4 and 5 will return or set the current position in 
      a text file. Furthermore, Mode 3 will return the resulting pointer in a 
      binary file.<br>
      <br>
      The typical usage is </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IOSEEK(hFile%,IoMode%,Offset&amp;)</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">, 
      where </font><font face="Courier New, Courier, mono" size="-1">hFile%</font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      is the relevant handle returned by </font><font face="Courier New, Courier, mono" size="-1">IOOPEN</font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">, 
      and </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IoMode%</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      is the </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IOSEEK</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      Mode. The </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      is used to specify or receive pointers and positions.<br>
      <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IoMode%=1</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      will set the pointer in a binary file to the absolute value specified in 
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">.<br>
      <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IoMode%=2</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">, 
      will set the pointer in a binary file to </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      bytes from the end of the file, i.e. </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      is here equal to </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">FileSize&amp;-AbsoluteOffset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">.<br>
      <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IoMode%=3</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      will set the pointer in a binary file to </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      bytes relative to the current position. At the same time, </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      will also be set to the resulting pointer. In other words, if </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;=0</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">, 
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IOSEEK(hFile%,3,Offset&amp;)</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      will make </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      take the value of the current pointer. This is sometimes not clearly documented 
      either.<br>
      <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IoMode%=4</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      will set </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      to the current position in a text file.<br>
      <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IoMode%=5</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      will set the current position in a text file to </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">.<br>
      <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IoMode%=6</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      will rewind a text file to the first position. </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Offset&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
      is not used, but you must still pass it as a argument.<br>
      <br>
      Take note that by convention we talk about 'pointers' when handling binary 
      files (Modes 1-3) and 'positions' when handling text files (Modes 4-6).</font></td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0005"></a>dpNote 
      0005<br>
      <br>
      </b>15 July 2002</font><font size="-1"><br>
      <br>
      <font face="Arial, Helvetica, sans-serif" color="#000080">All OPL versions </font></font></td>
    <td width="700"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Calculating 
        UID checksum</font></b><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">Want to define 
        your own file formats? You will need to extract the UID4 from the</font></font> 
        <font face="Courier New, Courier, mono" size="-1">SyUIDCheckSum$:</font><font color="#000080" face="Arial, Helvetica, sans-serif" size="-1"> 
        function. But this function, though you are passing three long integers 
        to it, returns a string. And this string contains the other UIDs as well. 
        This procedure helps you extract the UID4 as a long integer.</font><font size="-1"><br>
        <br>
        <font face="Courier New, Courier, monospace">INCLUDE &quot;System.oxh&quot;<br>
        <br>
        rem CONST </font><font color="#000080" face="Arial, Helvetica, sans-serif" size="-1"><font color="#000000" face="Courier New, Courier, monospace">KTextHeader%=1 // ER1-ER5</font></font><font face="Courier New, Courier, monospace"><br>
        CONST KTextHeader%=2 // ER6-ER7<br>
        <br>
        PROC UidCheckSum&amp;:(aUid1&amp;,aUid2&amp;,aUid3&amp;)<br>
        LOCAL Header$(16),UidNo%,Uid&amp;<br>
        // the System.opx function returns the complete file header as a string<br>
        Header$=SyUidCheckSum$:(aUid1&amp;,aUid2&amp;,aUid3&amp;) // ER6 and later<br>
        rem <font size="-1">Header$=CheckUid$:(aUid1&amp;,aUid2&amp;,aUid3&amp;) // ER5 and earlier </font><br>
        // since we entered LongInt values, we should return LongInt values <br>
        // by setting this to 1,2,3 the other UIDs can be returned<br>
        // </font></font><font face="Courier New, Courier, monospace" size="-1">but 
        this is of course not needed here<br>
        UidNo%=4<br>
        Uid&amp;=PEEKL(ADDR(Header$)+KTextHeader%+(UidNo%-1)*4)<br>
        RETURN Uid&amp;<br>
        ENDP<br>
        </font><font face="Courier New, Courier, mono" size="-1"><br>
        </font><font color="#000080" face="Arial, Helvetica, sans-serif" size="-1">See <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0005">dpNote 0005</a> about the value of  <font color="#000000" face="Courier New, Courier, monospace">KTextHeader%</font>. </font><font face="Courier New, Courier, mono" size="-1"><br>
        </font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0006"></a>dpNote 
      0006<br>
      <br>
      </b>15 July 2002</font><font size="-1"><br>
      <br>
      <font face="Arial, Helvetica, sans-serif" color="#000080">All OPL versions </font></font></td>
    <td width="700"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Handling 
        of simple stacks <br>
        <br>
        </font></b><font face="Arial, Helvetica, sans-serif" color="#000080">This 
        dpNote contains some general routines for stack handling. They can be 
        used as a framework to build more advanced data formats, e.g. multidimensional 
        arrays, lists and trees etc, as OPL does not have inherent support for 
        these. Here, the stack routines are written to handle short integer values. 
        They can easily be modified to handle values of other byte sizes.<br>
        <font face="Courier New, Courier, mono"><br>
        </font></font></font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">CONST 
        KStackShortHeader%=4<br>
        CONST KShortSize&amp;=2<br>
        <br>
        </font></font><font face="Courier New, Courier, mono" size="-1">PROC StackShortCreate&amp;:<br>
        // Usage: pStack&amp;=StackShortCreate&amp;<br>
        LOCAL p&amp;<br>
        p&amp;=ALLOC(KStackShortHeader%)<br>
        // 0 items so far <br>
        POKEL p&amp;,&amp;0000<br>
        RETURN p&amp;<br>
        ENDP<br>
        <br>
        PROC StackShortDestroy:(apStack&amp;)<br>
        FREEALLOC apStack&amp;<br>
        ENDP <br>
        <br>
        PROC StackShortEmptyB%:(apStack&amp;)<br>
        // returns KTrue% if stack is empty<br>
        RETURN (PEEKL(apStack&amp;)=&amp;0000)<br>
        ENDP <br>
        <br>
        PROC StackShortDepth&amp;:(apStack&amp;)<br>
        // returns the number of items in the stack<br>
        RETURN PEEKL(apStack&amp;)<br>
        ENDP<br>
        <br>
        PROC StackShortAddr&amp;:(apStack&amp;,aNo&amp;)<br>
        // returns the pointer address of a stack item number aNo&amp;<br>
        IF aNo&amp;&lt;1 OR aNo&amp;&gt;StackShortDepth&amp;:(apStack&amp;)<br>
        &nbsp;&nbsp;RAISE KErrInvalidStackNo%<br>
        ENDIF <br>
        RETURN apStack&amp;+</font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">KShortSize&amp;</font></font><font face="Courier New, Courier, mono" size="-1">*(aNo&amp;-1)+KStackShortHeader%<br>
        ENDP<br>
        <br>
        PROC StackShortRecall%:(apStack&amp;,aNo&amp;)<br>
        // returns the value of the item number aNo&amp;<br>
        // usage: Value%=StackShortRecall%:(pStack&amp;,Number%)<br>
        RETURN PEEKW(StackShortAddr&amp;:(apStack&amp;,aNo&amp;))<br>
        ENDP<br>
        <br>
        PROC StackShortStore:(apStack&amp;,aNo&amp;,aValue%)<br>
        // stores the value aValue% at position aNo&amp;<br>
        POKEW StackShortAddr&amp;:(apStack&amp;,aNo&amp;),aValue%<br>
        ENDP <br>
        <br>
        PROC StackShortPeek%:(apStack&amp;)<br>
        // returns the value of the item on top of the stack<br>
        // usage: Value%=StackShortPeek%:(pStack&amp;)<br>
        RETURN PEEKW(StackShortAddr&amp;:(apStack&amp;,StackShortDepth&amp;:(apStack&amp;)))<br>
        ENDP <br>
        <br>
        PROC StackShortPush&amp;:(apStack&amp;,aValue%)<br>
        // usage: pStack&amp;=StackShortPush&amp;:(pStack&amp;,Value%)<br>
        LOCAL pNew&amp;,size&amp;,NewNoItems&amp;<br>
        // calculate the new no of items <br>
        NewNoItems&amp;=1+StackShortDepth&amp;:(apStack&amp;) <br>
        // calculate the new cell size <br>
        size&amp;=KStackShortHeader%+KShortIntWidth&amp;*NewNoItems&amp; <br>
        // adjust to new cell size <br>
        pNew&amp;=REALLOC(apStack&amp;,size&amp;) <br>
        IF pNew&amp;=0<br>
&nbsp;&nbsp;RAISE KErrNoMemory%<br>
ENDIF<br>
// insert resulting number of items <br>
POKEL pNew&amp;,NewNoItems&amp; <br>
// insert value<br>
POKEW StackShortAddr&amp;:(pNew&amp;,NewNoItems&amp;),aValue%<br>
// return new pointer<br>
RETURN pNew&amp;<br>
ENDP<br>
        <br>
        PROC StackShortPop%:(apStack&amp;)<br>
        // usage: Value%=StackShortPop%:(pStack&amp;)<br>
        LOCAL Value%,OldNoItems&amp;,pNew&amp;,size&amp;,NewNoItems&amp;<br>
        IF StackShortEmptyB%:(apStack&amp;)<br>
&nbsp;&nbsp;RAISE KErrStackEmpty%<br>
ENDIF<br>
OldNoItems&amp;=StackShortDepth&amp;:(apStack&amp;) <br>
Value%=PEEKW(StackShortAddr&amp;:(apStack&amp;,OldNoItems&amp;))<br>
// calculate the new no of items<br>
NewNoItems&amp;=OldNoItems&amp;-1<br>
// calculate the new cell size<br>
size&amp;=KStackShortHeader%+KShortIntWidth&amp;*NewNoItems&amp;<br>
// adjust to new cell size<br>
pNew&amp;=REALLOC(apStack&amp;,size&amp;)<br>
// this check should not be needed, but let's check it anyway<br>
IF pNew&amp;&lt;&gt;apStack&amp;<br>
&nbsp;&nbsp;RAISE KErrShrinkCellFailure%<br>
ENDIF <br>
// insert resulting number of units <br>
POKEL pNew&amp;,NewNoItems&amp;<br>
// return popped value<br>
RETURN Value%<br>
ENDP</font><font size="-1"><br>
        </font><font face="Courier New, Courier, mono" size="-1"><br>
        PROC StackShortClear:(apStack&amp;)<br>
        // guarantees that the pointer value is the same,<br>
        // </font><font face="Courier New, Courier, mono" size="-1">which StackShortDestroy: 
        followed by StackShortCreate&amp;: would not<br>
        LOCAL pNew&amp;<br>
        // shrinking the cell<br>
        pNew&amp;=REALLOC(apStack&amp;,KStackShortHeader%)<br>
        // this check should not be needed, but let's check it anyway<br>
        IF pNew&amp;&lt;&gt;apStack&amp;<br>
        &nbsp;&nbsp;RAISE KErrShrinkCellFailure%<br>
        ENDIF<br>
        // zero the counter<br>
        POKEL apStack&amp;,&amp;0000<br>
        ENDP <br>
        <br>
        PROC StackShortDelete:(apStack&amp;,aNo&amp;)<br>
        // deletes an item without changing the order of other items<br>
        LOCAL OldNoOfItems&amp;,Item&amp;<br>
        OldNoOfItems&amp;=StackShortDepth&amp;:(apStack&amp;)<br>
        // copy all items above the deleted item one step downwards<br>
        Item&amp;=aNo&amp;<br>
        WHILE Item&amp;&lt;OldNoOfItems&amp;<br>
        &nbsp;&nbsp;StackShortStore:(apStack&amp;,Item&amp;,StackShortRecall%:(apStack&amp;,Item&amp;+1))<br>
        &nbsp;&nbsp;Item&amp;=Item&amp;+1<br>
        ENDWH<br>
        // remove the last item<br>
        StackShortPop%:(apStack&amp;)<br>
        ENDP <br>
        <br>
        PROC StackShortSwap:(apStack&amp;,aNo1&amp;,aNo2&amp;)<br>
        LOCAL tmp%<br>
        tmp%=StackShortRecall%:(apStack&amp;,aNo1&amp;)<br>
        StackShortStore:(apStack&amp;,aNo1&amp;,StackShortRecall%:(apStack&amp;,aNo2&amp;))<br>
        StackShortStore:(apStack&amp;,aNo2&amp;,tmp%) <br>
        ENDP<br>
        <br>
        PROC StackShortMirror:(apStack&amp;)<br>
        // turns the stack inside-out so that what was previously on top,<br>
        // is now at the bottom etc<br>
        LOCAL LastNo&amp;,MiddleNo&amp;,q&amp;,tmp%<br>
        IF StackShortEmptyB%:(apStack&amp;)<br>
        &nbsp;&nbsp;RAISE KErrStackEmpty%<br>
        ENDIF<br>
        LastNo&amp;=StackShortDepth&amp;:(apStack&amp;)<br>
        // no point doing stack mirror if no of items less than 2<br>
        IF LastNo&amp;&lt;2<br>
        &nbsp;&nbsp;RETURN<br>
        ENDIF<br>
        // doesn't actually matter if LastNo&amp; is even or odd<br>
        MiddleNo&amp;=LastNo&amp;/2<br>
        q&amp;=1<br>
        DO<br>
        &nbsp;&nbsp;StackShortSwap:(apStack&amp;,q&amp;,LastNo&amp;+1-q&amp;)<br>
        &nbsp;&nbsp;q&amp;=q&amp;+1<br>
        UNTIL q&amp;&gt;MiddleNo&amp;<br>
        ENDP<br>
        <br>
        PROC StackShortOccurrences%:(apStack&amp;,aValue%)<br>
        // returns number of occurrences of a value<br>
        LOCAL found%,i&amp;,NoOfItems&amp;<br>
        found%=0<br>
        NoOfItems&amp;=StackShortDepth&amp;:(apStack&amp;)<br>
        IF NoOfItems&amp;=0<br>
        &nbsp;&nbsp;RETURN found%<br>
        ENDIF<br>
        i&amp;=1<br>
        DO<br>
        &nbsp;&nbsp;IF aValue%=StackShortRecall%:(apStack&amp;,i&amp;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;found%=found%+1<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;i&amp;=i&amp;+1<br>
        UNTIL i&amp;&gt;NoOfItems&amp;<br>
        RETURN found%<br>
        ENDP<br>
        <br>
        PROC StackShortFind&amp;:(apStack&amp;,aValue%)<br>
        // returns position of first occurrence of a value counted from top<br>
        // returns 0 if not found<br>
        LOCAL position&amp;,NoOfItems&amp;<br>
        position&amp;=0<br>
        IF StackShortEmptyB%:(apStack&amp;)<br>
        &nbsp;&nbsp;RETURN position&amp;<br>
        ENDIF <br>
        NoOfItems&amp;=StackShortDepth&amp;:(apStack&amp;)<br>
        position&amp;=NoOfItems&amp;<br>
        DO<br>
        &nbsp;&nbsp;IF aValue%=StackShortRecall%:(apStack&amp;,position&amp;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;BREAK<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;position&amp;=position&amp;-1<br>
        UNTIL position&amp;=0<br>
        RETURN position&amp;<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0007"></a>dpNote&nbsp;0007</b><br>
      <br>
      28 Aug 2002<br>
      (Updated<br>
      4 Dec 2003</font><font size="-1">)<br>
      <br>
      <font face="Arial, Helvetica, sans-serif" color="#000080">All OPL versions </font></font></td>
    <td width="700"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Multi-dimensional 
        arrays </font></b><br>
        <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">OPL 
        keywords do not support multidimensional arrays. But it is reasonably 
        easy to implement it using the stack model of <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0006">dpNote 
        0006</a>. In this example we are looking at some procedures for handling 
        integer two dimensional arrays.<br>
        <br>
        The code is calling procedures and using constants of the <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0006">dpNote 
        0006</a>.<br>
        <br>
        </font><font face="Courier New, Courier, mono" size="-1">PROC ArrayDim&amp;:(aNoOfColumns%,aNoOfRows%)<br>
        // this procedure sets up the array and remembers its dimension - similar 
        to the<br>
        // </font><font face="Courier New, Courier, mono" size="-1">DIM command 
        of some BASIC dialects. Just remember that Column comes before Row,<br>
        // just as x comes before y.<br>
        // Usage pMyArray&amp;=ArrayDim&amp;:(NumberOfColumns%,NumberOfRows%)<br>
        LOCAL pArray&amp;,TotalNoOfPositions%,i%<br>
        // calculate the total number of positions<br>
        TotalNoOfPositions%=aNoOfColumns%*aNoOfRows%<br>
        // create stack<br>
        pArray&amp;=StackShortCreate&amp;:<br>
        pArray&amp;=StackShortPush&amp;:(pArray&amp;,aNoOfColumns%) // remember no 
        of columns in 1st header<br>
        pArray&amp;=StackShortPush&amp;:(pArray&amp;,aNoOfRows%) // remember no of 
        rows in 2nd header<br>
        // initialise the complete array to zero. You could also use REALLOC for 
        this,<br>
        // but that would not guarantee that all variables in the array are set 
        to zero<br>
        i%=1<br>
        WHILE i%&lt;=TotalNoOfPositions%<br>
&nbsp;&nbsp;pArray&amp;=StackShortPush&amp;:(pArray&amp;,$0)<br>
&nbsp;&nbsp;i%=i%+1 <br>
        ENDWH<br>
        // return the pointer<br>
        RETURN pArray&amp;<br>
        ENDP<br>
        <br>
        PROC ArrayGetCols%:(apArray&amp;)<br>
        RETURN StackShortRecall%:(apArray&amp;,&amp;0001)<br>
        ENDP<br>
        <br>
        PROC ArrayGetRows%:(apArray&amp;)<br>
        RETURN StackShortRecall%:(apArray&amp;,&amp;0002)<br>
        ENDP<br>
        <br>
        PROC ArrayPos&amp;:(apArray&amp;,aCol%,aRow%)<br>
        // returns the position of the element of an array item (aCol%,aRow%)<br>
        LOCAL Position&amp;,TotalCol%,TotalRow%<br>
        // obtain the array size<br>
        TotalCol%=ArrayGetCols%:(apArray&amp;)<br>
        TotalRow%=ArrayGetRows%:(apArray&amp;)<br>
        // check that the position is valid, and give error if otherwise<br>
        IF aCol%&lt;1 OR aCol%&gt;TotalCol% OR aRow%&lt;1 OR aRow%&gt;TotalRow%<br>
&nbsp;&nbsp;RAISE KErrInvalidStackNo%<br>
        ENDIF<br>
        // return position and add 2 for the header<br>
        Position&amp;=(aRow%-1)*TotalCol%+aCol%+2<br>
        RETURN Position&amp;<br>
        ENDP<br>
        <br>
        PROC ArrayAddr&amp;:(apArray&amp;,aCol%,aRow%)<br>
        // returns the pointer address of the array item (aCol%,aRow%)<br>
        RETURN StackShortAddr&amp;:(apArray&amp;,ArrayPos&amp;:(apArray&amp;,aCol%,aRow%))<br>
        ENDP <br>
        <br>
        PROC ArraySto:(apArray&amp;,aCol%,aRow%,aValue%)<br>
        // stores the value aValue% to array item (aCol%,aRow%) <br>
        StackShortStore:(apArray&amp;,ArrayPos&amp;:(apArray&amp;,aCol%,aRow%),aValue%) <br>
        ENDP<br>
        <br>
        PROC ArrayRcl%:(apArray&amp;,aCol%,aRow%)<br>
        // returns the value of the array item (aCol%,aRow%) <br>
        RETURN StackShortRecall%:(apArray&amp;,ArrayPos&amp;:(apArray&amp;,aCol%,aRow%))<br>
        ENDP <br>
        <br>
        PROC ArrayDestroy:(apArray&amp;)<br>
        // erases array and frees up memory<br>
        StackShortDestroy:(apArray&amp;)<br>
        ENDP<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">Assume 
        now that we wish to create and populate a matrix A of 5 colums and 2 rows 
        and a matrix B of 2 columns and 3 rows, and then do some calculations, 
        this is how it can be done.<br>
        <br>
        </font><font face="Courier New, Courier, mono" size="-1">CONST KMatrixACol%=5<br>
        CONST KMatrixARow%=2<br>
        CONST KMatrixBCol%=2<br>
        CONST KMatrixBRow%=3<br>
        <br>
        PROC Main:<br>
        LOCAL A&amp;,B&amp; // matrix handlers<br>
        // initialise arrays<br>
        A&amp;=ArrayDim&amp;:(KMatrixACol%,KMatrixARow%)<br>
        B&amp;=ArrayDim&amp;:(KMatrixBCol%,KMatrixBRow%) <br>
        // populate array A with '25' in all positions<br>
        ArrayPopulate:(A&amp;,25)<br>
        // populate array B with '13' in all positions<br>
        ArrayPopulate:(B&amp;,13)<br>
        // add A(5,2) to B(2,3) and put in A(1,1) and print it, it should print 
        38<br>
        ArraySto:(A&amp;,1,1,ArrayRcl%:(A&amp;,5,2)+ArrayRcl%:(B&amp;,2,3))<br>
        PRINT ArrayRcl%:(A&amp;,1,1)<br>
        GET <br>
        // erase both arrays and release memory<br>
        ArrayDestroy:(A&amp;)<br>
        ArrayDestroy:(B&amp;) <br>
        ENDP<br>
        <br>
        PROC ArrayPopulate:(apArray&amp;,aValue%)<br>
        LOCAL i%,j%,TotalCol%,TotalRow%<br>
        TotalCol%=ArrayGetCols%:(apArray&amp;)<br>
        TotalRow%=ArrayGetRows%:(apArray&amp;)<br>
        i%=1<br>
        WHILE i%&lt;=TotalCol%<br>
&nbsp;&nbsp;j%=1 <br>
&nbsp;&nbsp;WHILE j%&lt;=TotalRow%<br>
&nbsp;&nbsp;&nbsp;&nbsp;ArraySto:(apArray&amp;,i%,j%,aValue%)<br>
&nbsp;&nbsp;&nbsp;&nbsp;j%=j%+1<br>
&nbsp;&nbsp;ENDWH<br>
&nbsp;&nbsp;i%=i%+1<br>
        ENDWH<br>
        ENDP<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">It 
        would now also be easy to write procedures for matrix addition and multiplication 
        etc, where the result is put in matrix C.<br>
        <br>
        </font><font face="Courier New, Courier, mono" size="-1">C&amp;=ArrayAdd&amp;:(A&amp;,B&amp;) 
        // should give error if A&amp; and B&amp; are not of same size<br>
        C&amp;=ArrayAddValue&amp;:(A&amp;,aValue%) <br>
        C&amp;=ArrayMultiply&amp;:(A&amp;,B&amp;) // assumes no of colums in A&amp; = no of rows in B&amp;</font><br>
        <font face="Courier New, Courier, mono" size="-1">C&amp;=ArrayMultiplyByValue&amp;:(A&amp;,aValue%)</font> 
        <br>
        <br>
        <font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">But 
        we won't do it this time.<br>
        </font> </p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0008" id="dpNote0008"></a>dpNote&nbsp;0008</b><br>
        <br>
28 Aug 2002<br>
    <br>
    1 Jan 2006<br>
    <br>
    All OPL versions
</font><font size="-1"><br>
</font></td>
    <td><p><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><strong>Stack of buffers with configurable size</strong><br> 
      <br>
      In <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0006">dpNote0006</a> we looked at a simple byte stack. In dpModule.opo there are ready made stacks available for:<br>
        <br>
        - Byte </font><font size="-1" face="Courier New, Courier, monospace">(StackByte...)</font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        - Word / short integer  </font><font size="-1" face="Courier New, Courier, monospace">(StackShort...) </font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        - Long integer  </font><font size="-1" face="Courier New, Courier, monospace">(StackLong...)</font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        - Float  </font><font size="-1" face="Courier New, Courier, monospace">(StackFloat...)</font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        - Complex (two floats)  </font><font size="-1" face="Courier New, Courier, monospace">(StackComplex...)</font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        - String with configurable length  </font><font size="-1" face="Courier New, Courier, monospace">(StackString...)</font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        - Buffer with configurable size </font><font size="-1" face="Courier New, Courier, monospace">(StackBuffer...)</font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        <br>
This dpNote will demonstrate a stack of buffers with configurable size.<br>
        </font><font size="-1" face="Courier New, Courier, monospace"><br>
    // the StackBufferHeader has depth stored in the first four bytes and the<br>
        // size of buffer stored in the next four bytes<br>
        CONST KStackBufferHeader&amp;=&amp;0008<br>
        CONST KStackBufferSizeOffset&amp;=&amp;0004<br>
        <br>
    PROC StackBufferCreate&amp;:(aBufferSize&amp;)<br>
        // Usage:  pStack&amp;=StackBufferCreate&amp;<br>
        LOCAL pStack&amp;<br>
        pStack&amp;=ALLOC(KStackBufferHeader&amp;)<br>
        // 0 items so far<br>
        POKEL pStack&amp;,&amp;00000000<br>
        POKEL (pStack&amp;+KStackBufferSizeOffset&amp;),aBufferSize&amp;<br>
        RETURN pStack&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferDestroy:(apStack&amp;)<br>
        FREEALLOC apStack&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferDepth&amp;:(apStack&amp;)<br>
        // returns the number of items in a stack<br>
        RETURN PEEKL(apStack&amp;)<br>
        ENDP<br>
        <br>
    PROC StackBufferSize&amp;:(apStack&amp;)<br>
        // returns the size of each buffer item<br>
        RETURN PEEKL(apStack&amp;+KStackBufferSizeOffset&amp;)<br>
        ENDP<br>
        <br>
    PROC StackBufferEmptyB%:(apStack&amp;)<br>
        // returns KTrue% if stack is empty<br>
        RETURN (PEEKL(apStack&amp;)=&amp;00000000)<br>
        ENDP<br>
        <br>
    PROC StackBufferAddr&amp;:(apStack&amp;,aNo&amp;)<br>
        // returns the pointer address of a stack item aNo&amp;<br>
        IF aNo&amp;&lt;1 OR aNo&amp;&gt;StackBufferDepth&amp;:(apStack&amp;)<br>
&nbsp;&nbsp;RAISE KErrInvalidStackNo%<br>
        ENDIF<br>
        RETURN apStack&amp;+StackBufferOffset&amp;:(apStack&amp;,aNo&amp;)<br>
        ENDP<br>
        <br>
    PROC StackBufferOffset&amp;:(apStack&amp;,aNo&amp;)<br>
        RETURN (StackBufferSize&amp;:(apStack&amp;)*(aNo&amp;-1)+KStackBufferHeader&amp;)<br>
        ENDP<br>
        <br>
    PROC StackBufferRecallN&amp;:(apStack&amp;,aNo&amp;)<br>
        // allocates and returns a pointer to a Buffer value<br>
// Usage: pBuffer&amp;=StackBufferRecallN&amp;:(pStack&amp;,Number%)<br>
// the N indicates that a new buffer is created <br>
        LOCAL pBuffer&amp;,BufferSize&amp;<br>
        BufferSize&amp;=StackBufferSize&amp;:(apStack&amp;)<br>
        pBuffer&amp;=ALLOC(BufferSize&amp;)<br>
        BufferCopy:(pBuffer&amp;,StackBufferAddr&amp;:(apStack&amp;,aNo&amp;),BufferSize&amp;)<br>
        RETURN pBuffer&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferStore:(apStack&amp;,aNo&amp;,apBuffer&amp;)<br>
        // stores the value aValue% at position aNo&amp;<br>
        BufferCopy:(StackBufferAddr&amp;:(apStack&amp;,aNo&amp;),apBuffer&amp;,StackBufferSize&amp;:(apStack&amp;))<br>
        ENDP<br>
        <br>
    PROC StackBufferStoreD:(apStack&amp;,aNo&amp;,apBuffer&amp;)<br>
        // stores the value aValue% at position aNo&amp;<br>
        // the D indicates that the buffer is destroyed <br>
        BufferCopy:(StackBufferAddr&amp;:(apStack&amp;,aNo&amp;),apBuffer&amp;,StackBufferSize&amp;:(apStack&amp;))<br>
        // destroy incoming cell<br>
        FREEALLOC(apBuffer&amp;)<br>
        ENDP<br>
        <br>
    PROC StackBufferPeekN&amp;:(apStack&amp;)<br>
        // returns a pointer of the item on top of the stack<br>
// usage: pBuffer&amp;=StackBufferPeek&amp;:(apStack&amp;)<br> 
// the N indicates that a new buffer is created
<br>
        LOCAL pBuffer&amp;,BufferSize&amp;<br>
        BufferSize&amp;=StackBufferSize&amp;:(apStack&amp;)<br>
        pBuffer&amp;=ALLOC(Size&amp;)<br>
        BufferCopy:(pBuffer&amp;,StackBufferAddr&amp;:(apStack&amp;,StackBufferDepth&amp;:(apStack&amp;)),BufferSize&amp;)<br>
        RETURN pBuffer&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferPush&amp;:(apStack&amp;,apBuffer&amp;)<br>
        // Usage: pStack&amp;=StackBufferPush&amp;:(pStack&amp;,pBuffer&amp;)<br>
        LOCAL pNew&amp;,size&amp;,NewNoItems&amp;,BufferSize&amp;<br>
        BufferSize&amp;=StackBufferSize&amp;:(apStack&amp;)<br>
        // calculate the new no of items<br>
        NewNoItems&amp;=1+StackBufferDepth&amp;:(apStack&amp;)<br>
        // calculate the new cell size and adjust cell<br>
        size&amp;=KStackBufferHeader&amp;+BufferSize&amp;*NewNoItems&amp;<br>
        pNew&amp;=REALLOC(apStack&amp;,size&amp;)<br>
        IF pNew&amp;=&amp;0<br>
        &nbsp;&nbsp;RAISE KErrNoMemory%<br>
        ENDIF<br>
        // insert resulting number of items<br>
        POKEL pNew&amp;,NewNoItems&amp;<br>
        // insert new value<br>
        BufferCopy:(StackBufferAddr&amp;:(pNew&amp;,NewNoItems&amp;),apBuffer&amp;,BufferSize&amp;)<br>
        // return new pointer<br>
        RETURN pNew&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferPushD&amp;:(apStack&amp;,apBuffer&amp;)<br>
        // Usage: pStack&amp;=StackBufferPushD&amp;:(pStack&amp;,pBuffer&amp;)<br>
    // the D indicates that the buffer is destroyed <br>
    LOCAL pNew&amp;<br>
    pNew&amp;=StackBufferPush&amp;:(apStack&amp;,apBuffer&amp;)<br>
    FREEALLOC(apBuffer&amp;)<br>
        // return new pointer<br>
        RETURN pNew&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferPopN&amp;:(apStack&amp;)<br>
        // usage: pBuffer&amp;=StackBufferPop&amp;:(pStack&amp;)<br>
        // the N indicates that a new buffer is created
        <br>
        LOCAL Value%,NoItems&amp;,size&amp;,pBuffer&amp;,BufferSize&amp;<br>
        IF StackBufferEmptyB%:(apStack&amp;)<br>
        &nbsp;&nbsp;RETURN &amp;0000<br>
        ENDIF<br>
        BufferSize&amp;=StackBufferSize&amp;:(apStack&amp;)<br>
        NoItems&amp;=StackBufferDepth&amp;:(apStack&amp;)<br>
        // get the value to be popped<br>
        pBuffer&amp;=ALLOC(BufferSize&amp;)<br>
        BufferCopy:(pBuffer&amp;,StackBufferAddr&amp;:(apStack&amp;,NoItems&amp;),BufferSize&amp;)<br>
        // calculate the new no of items<br>
        NoItems&amp;=NoItems&amp;-1<br>
        // calculate the new cell size<br>
        size&amp;=KStackBufferHeader&amp;+BufferSize&amp;*NoItems&amp;<br>
        // adjust to new cell size. since we're reducing we don't need to update pointer<br>
        REALLOC(apStack&amp;,size&amp;)<br>
        // insert resulting number of units<br>
        POKEL apStack&amp;,NoItems&amp;<br>
        // return popped value<br>
        RETURN pBuffer&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferClear:(apStack&amp;)<br>
        // guarantees that the pointer value is the same,<br>
        // which StackBufferDestroy: followed by StackBufferCreate&amp;: would not.<br>
        //<br>
        // shrinking the cell, since we're reducing we don't need to update pointer<br>
        REALLOC(apStack&amp;,KStackBufferHeader&amp;)<br>
        // zero the counter<br>
        POKEL apStack&amp;,&amp;0000<br>
        ENDP<br>
        <br>
    PROC StackBufferDelete:(apStack&amp;,aNo&amp;)<br>
        // deletes an item without changing the order of other items<br>
        LOCAL NoOfItems&amp;<br>
        NoOfItems&amp;=StackBufferDepth&amp;:(apStack&amp;)<br>
        IF aNo&amp;&gt;NoOfItems&amp;<br>
        &nbsp;&nbsp;RAISE KErrInvalidStackNo%<br>
        ENDIF<br>
        ADJUSTALLOC(apStack&amp;,StackBufferOffset&amp;:(apStack&amp;,aNo&amp;),-StackBufferSize&amp;:(apStack&amp;))<br>
        // update header counter<br>
        POKEL apStack&amp;,(NoOfItems&amp;-1)<br>
        ENDP<br>
        <br>
    PROC StackBufferInsertD&amp;:(apStack&amp;,aNo&amp;,apBuffer&amp;)<br>
        // inserts an item without changing the order of other items<br>
        // aNo&amp; is the place where the insertion is done<br>
        // the D indicates that the incoming buffer is destroyed <br>
        LOCAL NoOfItems&amp;,Item&amp;,pNew&amp;<br>
        // increase no of items<br>
        NoOfItems&amp;=1+StackBufferDepth&amp;:(apStack&amp;)<br>
        // handle out of range cases<br>
        IF aNo&amp;&gt;=NoOfItems&amp;<br>
        &nbsp;&nbsp;Item&amp;=NoOfItems&amp;<br>
        ELSEIF aNo&amp;&lt;=&amp;0<br>
        &nbsp;&nbsp;Item&amp;=1<br>
        ELSE<br>
        &nbsp;&nbsp;Item&amp;=aNo&amp;<br>
        ENDIF<br>
        // increase cell size with one item<br>
        pNew&amp;=ADJUSTALLOC(apStack&amp;,StackBufferOffset&amp;:(apStack&amp;,Item&amp;),StackBufferSize&amp;:(apStack&amp;))<br>
        IF pNew&amp;=&amp;0<br>
        &nbsp;&nbsp;RAISE KErrNoMemory%<br>
        ENDIF<br>
        // update header<br>
        POKEL pNew&amp;,NoOfItems&amp;<br>
        // store value and destroy the incoming cell<br>
        StackBufferStoreD:(pNew&amp;,Item&amp;,apBuffer&amp;)<br>
        // return new pointer<br>
        RETURN pNew&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferSwap:(apStack&amp;,aNo1&amp;,aNo2&amp;)<br>
        LOCAL pTmp&amp;<br>
        pTmp&amp;=StackBufferRecallN&amp;:(apStack&amp;,aNo1&amp;)<br>
        StackBufferStoreD:(apStack&amp;,aNo1&amp;,StackBufferRecallN&amp;:(apStack&amp;,aNo2&amp;))<br>
        StackBufferStoreD:(apStack&amp;,aNo2&amp;,pTmp&amp;)<br>
        ENDP<br>
        <br>
    PROC StackBufferMirror:(apStack&amp;)<br>
        // turns the stack inside-out so that what was previously on top<br>
        // is now at the bottom etc<br>
        LOCAL LastNo&amp;,MiddleNo&amp;,q&amp;<br>
        LastNo&amp;=StackBufferDepth&amp;:(apStack&amp;)<br>
        // no point in doing stack mirror if no of items less than 2<br>
        IF LastNo&amp;&lt;2<br>
        &nbsp;&nbsp;RETURN<br>
        ENDIF <br>
        MiddleNo&amp;=LastNo&amp;/2<br>
        q&amp;=1<br>
        DO<br>
        &nbsp;&nbsp;StackBufferSwap:(apStack&amp;,q&amp;,LastNo&amp;+1-q&amp;)<br>
        &nbsp;&nbsp;q&amp;=q&amp;+1<br>
        UNTIL q&amp;&gt;MiddleNo&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferOccurrences%:(apStack&amp;,apBuffer&amp;)<br>
        LOCAL found%,i&amp;,NoOfItems&amp;,pValue&amp;<br>
        found%=$0<br>
        NoOfItems&amp;=StackBufferDepth&amp;:(apStack&amp;)<br>
        IF NoOfItems&amp;=&amp;0<br>
        &nbsp;&nbsp;RETURN found%<br>
        ENDIF<br>
        i&amp;=1<br>
        DO<br>
        &nbsp;&nbsp;pValue&amp;=StackBufferRecallN&amp;:(apStack&amp;,i&amp;)<br>
        &nbsp;&nbsp;IF StackBufferIdenticalB%:(apBuffer&amp;,pValue&amp;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;found%=found%+1<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;FREEALLOC(pValue&amp;)<br>
        &nbsp;&nbsp;i&amp;=i&amp;+1<br>
        UNTIL i&amp;&gt;NoOfItems&amp;<br>
        RETURN found%<br>
        ENDP<br>
        <br>
    PROC StackBufferFind&amp;:(apStack&amp;,apBuffer&amp;)<br>
        // returns position of first occurrence of a value counted from top<br>
        // returns 0 if not found<br>
        LOCAL position&amp;,NoOfItems&amp;,pComparison&amp;<br>
        position&amp;=&amp;0<br>
        IF StackBufferEmptyB%:(apStack&amp;)<br>
        &nbsp;&nbsp;RETURN position&amp;<br>
        ENDIF<br>
        NoOfItems&amp;=StackBufferDepth&amp;:(apStack&amp;)<br>
        position&amp;=NoOfItems&amp;<br>
        DO<br>
        &nbsp;&nbsp;pComparison&amp;=StackBufferRecallN&amp;:(apStack&amp;,position&amp;)<br>
        &nbsp;&nbsp;IF StackBufferIdenticalB%:(apBuffer&amp;,pComparison&amp;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;BREAK<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;FREEALLOC(pComparison&amp;)<br>
        &nbsp;&nbsp;position&amp;=position&amp;-&amp;1<br>
        UNTIL position&amp;=&amp;0<br>
        RETURN position&amp;<br>
        ENDP<br>
        <br>
    PROC StackBufferIdenticalB%:(apValue1&amp;,apValue2&amp;)<br>
        LOCAL BufferSize&amp;,oIndex&amp;<br>
        BufferSize&amp;=StackBufferSize&amp;:(apValue1&amp;)<br>
        IF BufferSize&amp;&lt;&gt;StackBufferSize&amp;:(apValue2&amp;)<br>
        &nbsp;&nbsp;RETURN KFalse%<br>
        ENDIF<br>
        oIndex&amp;=0<br>
        WHILE oIndex&amp;&lt;BufferSize&amp;<br>
        &nbsp;&nbsp;IF PEEKB(apValue1&amp;+oIndex&amp;)&lt;&gt;PEEKB(apValue2&amp;+oIndex&amp;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;RETURN KFalse%<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;oIndex&amp;=oIndex&amp;+&amp;1<br>
        ENDWH<br>
        RETURN KTrue%<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b><a name="dpNote0009"></a>dpNote&nbsp;0009</b><br>
      <br>
      28 Aug 2002</font><font size="-1"><br>
      <br>
      <font face="Arial, Helvetica, sans-serif" color="#000080">v6 Series 80 R1<br>
      <br>
      v6 Series 80 WINS</font></font></td>
    <td width="700"> 
      <p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Getting 
        the serial (IMEI) number of a Nokia 9200 Series Communicator</font></b><br>
        <br>
      </font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">The 
        serial number is the one normally written below the barcode and it only 
        becomes visible once you remove the battery. Of course you can also get 
        it from the phone screen by pressing *#06#. The number is also referred 
        to as the IMEI number.<br>
        </font><font face="Courier New, Courier, mono" size="-1"><br>
        INCLUDE &quot;System.oxh&quot;<br>
        <br>
        CONST KWINSSerialNumber$=&quot;111111111111111&quot;<br>
        <br>
        PROC SerialNumberGet$:<br>
        // first check if the routine is run in WINS, because there is <br>
        // a bug in SyGetPhoneInfo$:, it hangs when run from emulator<br>
        IF MachineTypeGet&amp;:&lt;&gt;KSyMachineUid_Win32Emulator&amp;<br>
&nbsp;&nbsp;// SyGetPhoneInfo$: returns a 16 character string. The rightmost<br>
&nbsp;&nbsp;// character is unknown. It needs to be truncated off<br>
&nbsp;&nbsp;// to avoid any issues with later comparisons.<br>
&nbsp;&nbsp;RETURN LEFT$(SyGetPhoneInfo$:(KPhoneInfoSerialNumber%),15)<br>
        ELSE<br>
&nbsp;&nbsp;// if run from WINS, return a faked serial number<br>
&nbsp;&nbsp;RETURN KWINSSerialNumber$<br>
        ENDIF<br>
        ENDP<br>
        <br>
        PROC MachineTypeGet&amp;:<br>
        LOCAL value&amp;,return&amp;<br>
        value&amp;=0<br>
        return&amp;=SyGetHAL&amp;:(KSyMachineUID&amp;,value&amp;)<br>
        RETURN value&amp;<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0010"></a></b>dpNote 
        0010</font></b><font color="#000080"><br>
        <br>
        3 Sep 2002<br>
        <br>
        v6 Series 80 <br>
        WINS </font></font></p>    </td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Making 
        the v6/S80 WINS Emulator more programmer friendly for OPL development</font></b></font><font size="-1"><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">We find it most 
        practical to program OPL in the WINS Emulator. In WINS for v5.0 there 
        was a &quot;Psion 5mx/netBook-style&quot; VGA console. As far as we are 
        concerned using this console provides the best trade-off between overview 
        and ability to view other windows on the PC screen at the same time. Moreover, 
        the width is 640 pixels, exactly like the Nokia Communicator's screen. 
        But the height is 480 pixels in lieu of the Communicator's 200 pixels.<br>
        <br>
        Once you have installed the WINS emulator on a PC, usually the WINS console 
        layout is defined in the </font></font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">C:\Symbian\6.0\NokiaCPP\Epoc32\Data</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        folder. This is done in the </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">epoc.ini</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        file. The console image used is defined by the statements:<br>
        <br>
        </font><font face="Courier New, Courier, mono" size="-1"># screen size and location<br>
        ScreenWidth 640<br>
        ScreenHeight 200<br>
        ScreenOffsetX 137<br>
        ScreenOffsetY 62<br>
        fasciabitmap 9210Small.bmp</font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><br>
        <br>
        Now, you can change these values to fit the WINS v5 VGA console.<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono"># 
        screen size and location<br>
        ScreenWidth 640<br>
        ScreenHeight 480<br>
        ScreenOffsetX 87<br>
        ScreenOffsetY 48<br>
        fasciabitmap VGA9210.bmp</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><br>
        <br>
        The first time we did it, we noted that some things in the Series 80 release 1 are hardcoded and some are softcoded. For instance the status 
        bar to the left seems hardcoded, as the battery symbol etc does not move 
        to the bottom. But the CBA to the right seems softcoded, so the buttons 
        spread out over the available height. This requires some tweaking of the 
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">epoc.ini</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> file so as to fit the CBA button areas to their new locations. And the 
        CBA buttons will need to be located correctly in the image, since they 
        are literally &quot;hardcoded&quot; on a Communicator and not like the 
        Toolbar of v5.0 vintage.<br>
        <br>
        Furthermore, the &quot;Psion 5mx-style&quot; silkscreen buttons below 
        the screen have to be replaced by the Series 80 application buttons. This 
        requires pasting of the application button image and aligning the corresponding 
        parameters in the </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">epoc.ini</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        file to the new location.<br>
        <br>
        And lastly, almost all the Symbian OS v5.0 machines, including the netPad, 
        have silkscreen buttons to the left, which the Communicator does not have. 
        Well, we masked them out, except for the top one [Menu], which we found 
        practical to keep; it makes it easier to access the Menu than to hit F1. 
        This also means that definition of a new virtual key is needed.<br>
        <br>
        It all becomes a &quot;hybrid&quot; looking creation, but we find it very 
        practical. </font></p>
      <p><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/WINSpicture.jpg" width="804" height="612"><br>
        <br>
        If anyone wish to do this, the console image file and the epoc.ini file 
        are downloadable below. They should be put in </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">C:\Symbian\6.0\NokiaCPP\Epoc32\Data</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">.<br>
        <br>
        <b>Remember to backup or rename the existing epoc.ini file before you 
        replace it</b>. At the end of your OPL development you will probably want 
        to go back and test your application with a Nokia 9200 Series Communicator 
        console.<br>
        <br>
        Console image file: </font><font face="Arial, Helvetica, sans-serif" size="-1"><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/General_download/VGA9210.BMP"><font face="Courier New, Courier, mono">VGA9210.bmp</font></a></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        <br>
        Console settings file: </font><font face="Arial, Helvetica, sans-serif" size="-1"><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/General_download/epoc.ini"><font face="Courier New, Courier, mono">epoc.ini</font></a></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><font face="Courier New, Courier, mono">.<br>
        <br>
        <font face="Arial, Helvetica, sans-serif"><em>We have later discovered that what is described in this dpNote does not work for WINS for Series 80 release 2. </em></font></font><em>T</em></font><em><font size="-1" face="Arial, Helvetica, sans-serif"><font color="#000080">he UI of 9500 and 9300 appears differently coded.</font> </font><font size="-1"><br>
        </font></em></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0011"></a></b>dpNote 
      0011</font></b><font color="#000080"><br>
      <br>
      3 Sep 2002<br>
      <br>
      v6
      Series 80 R1 </font></font></td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Showing 
        the amount of free memory</font></b></font><font size="-1"><br>
        <br>
        <font face="Courier New, Courier, mono">INCLUDE &quot;System.oxh&quot;<br>
      INCLUDE &quot;Const.oph&quot;<br>
      <br>
        </font></font><font face="Courier New, Courier, mono" size="-1">PROC MessageFreeMemory:<br>
      Message:(&quot;Free RAM: &quot;+GEN$(FreeMemoryGet&amp;:/1024/1024,12)+&quot; 
        MBytes&quot;) <br>
      ENDP<br>
      <br>
        </font><font face="Courier New, Courier, mono" size="-1">PROC Message:(aMsg$)<br>
        gIPRINT aMsg$,KBusyTopRight%<br>
      ENDP<br>
      <br>
        </font><font face="Courier New, Courier, mono" size="-1">PROC FreeMemoryGet&amp;:<br>
      LOCAL TotalRam&amp;,TotalRom&amp;,MaxFreeRam&amp;,FreeRam&amp;<br>
      SyMemoryInfo:(TotalRam&amp;,TotalRom&amp;,MaxFreeRam&amp;,FreeRam&amp;)<br>
      RETURN FreeRam&amp;<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0012"></a></b>dpNote 
      0012</font></b><font color="#000080"><br>
      <br>
      4 Sep 2002<br>
      <br>
      All OPL versions </font></font></td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Naming 
        conventions<br>
        </font></b><font color="#000080"><br>
        Conventions are used to make coding easier. The larger the program, the 
        more sense they make. These are some of our naming conventions for constants, 
        variable names, procedure names etc that we use. Adopt it or leave it. 
        We have seen many other conventions from other developers which also make 
        sense. Whichever convention you use, it is helpful. <br>
        <br>
        <b>Constants</b> should commence with a capital 'K', e.g. </font><font face="Courier New, Courier, mono">KMaxStringLen%</font><font color="#000080">. 
        Some OPL documentations say that constants can only be used in OPL file 
        headers and in OPH files. In fact, they can be used anywhere in the code 
        outside a procedure as long as they are declared before they are used. 
        Therefore, constants can be &quot;local&quot; to a procedure. Just make 
        sure that their names do not clash with other constants.<br>
        <br>
        <b>Globals</b> should commence with a capital 'G', e.g. </font><font face="Courier New, Courier, mono">GScreenWidth%=gWIDTH</font><font color="#000080">. 
        Using this convention helps you remember which variables should be declared 
        with the </font><font face="Courier New, Courier, mono">EXTERNAL</font><font color="#000080"> 
        statment in procedures. It also helps you reducing the use of globals.<br>
        <br>
        <b>Variables passed by value</b> should commence with an 'a' in the receiving procedure, e.g.<br>
        <br>
        </font><font face="Courier New, Courier, mono">PROC LoadTextFileIntoBuffer&amp;:(aFileName$)<br>
        LOCAL pBuffer&amp;
        <br>
// do it<br>
RETURN      
pBuffer&amp;<br>
ENDP<br>
<br>
        <font color="#000080">could be called by </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">pMyTextBuffer&amp;=LoadTextFileIntoBuffer&amp;:(&quot;MyTextFile.txt&quot;)</font></font><br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080"><b>Variables passed by reference</b> should commence with an '_' in the receiving procedure. In this procedure the complex number Y is passed by value and added into the complex number X which is passed by reference and later returned by reference. <br>
        <br>
        </font><font face="Courier New, Courier, mono">PROC ComplexAdd:(_ReX&amp;,_ImX&amp;,aReY,aImY)<br>
        LOCAL ReX,ImX<br>
        // acquire values passed by reference <br>
        ReX=PEEKF(_ReX&amp;)</font></font><font face="Courier New, Courier, mono"> :<font size="-1"><font size="-1">ImX=PEEKF(_ImX&amp;)<font size="-1"><font size="-1"><br>
        // make complex number addition
        <br>
        </font></font></font></font>ReX=ReX+aReY :ImX=ImX+aImY<br>
        // return values <br>
        POKEF _ReX&amp;,ReX :POKEF _ImX&amp;,ImX<br>
        ENDP<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">The procedure could be called by:</font></font>        <font face="Arial, Helvetica, sans-serif" size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">ComplexAdd:(ADDR(ReZ),ADDR(ImZ),-2.7,4.3) </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">, after which ReZ and ImZ will have the resulting value. </font></font></font><font face="Courier New, Courier, mono"><br>
        </font></font></font><font face="Courier New, Courier, mono"><br>
        </font><font color="#000080"><b>Boolean variables</b>, i.e. variables that should 
        only take the value </font><font face="Courier New, Courier, mono">KTrue% 
        <font color="#000080">or</font> KFalse%<font color="#000080"> should </font></font><font color="#000080">end 
        with a 'B', e.g. </font><font face="Courier New, Courier, mono">GCbaVisibleB%</font><font color="#000080">. 
        In this case it is also a global variable. This is also recommended if 
        a procedure can only return </font><font face="Courier New, Courier, mono">KTrue% 
        <font color="#000080">or</font> KFalse%</font><font color="#000080"> e.g. 
        </font><font face="Courier New, Courier, mono">TitleBarVisibleB%:</font><font color="#000080">.</font><br>
        <br>
        <font color="#000080"><strong>Absolute Pointers</strong> should commence with a 'p', e.g. </font><font face="Courier New, Courier, mono">pStack&amp;=ALLOC(KStackHeader%)</font><font color="#000080"><br>
        <br>
        <strong>Relative Pointers</strong> (a.k.a. <strong>Offsets</strong>) should commence with an 'o', e.g. <font color="#000000" face="Courier New, Courier, monospace">oJumpTable&amp; </font><br>
        <br>
        <b>Handles</b>, for instance when using IO operations, should commence with a 
        'h' as in </font><font face="Courier New, Courier, mono">IOOPEN(hInfile%,aFileName$,IoMode%)</font><font color="#000080">.</font><br>
        <font color="#000080"><br>
        <b>Window ID</b>s, should end with 'WID', e.g. </font><font face="Courier New, Courier, mono">TitleWID%=gCREATE(0,0,TitleWidth%,ScreenHeight%,KVisible%,K4KColourMode%)</font><br>
        <br>
        <font color="#000080">Variables that are used for application and file 
        <b>UIDs</b> should end with 'UID', e.g. </font><font face="Courier New, Courier, mono">ApplicationUID&amp;</font><font color="#000080"> 
        <br>
        <br>
        Other types of <strong>IDs</strong>, e.g. for handling of <strong>sprites</strong>, should end with ID, 
        e.g. </font><font face="Courier New, Courier, mono">SpriteID&amp;=SpriteCreate&amp;:(TitleWID%,KHiddenPosXY%,KHiddenPosXY%,KFalse%)</font><font color="#000080"> 
        <br>
        <br>
        </font></font><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080"><b>Labels</b>        that are called from </font> <font face="Courier New, Courier, mono">GOTO</font><font color="#000080"> 
        and </font><font face="Courier New, Courier, mono">ONERR</font><font color="#000080"> 
        and the like should commence with 'LBL_', e.g. </font><font face="Courier New, Courier, mono">ONERR 
        LBL_Cleanup::</font></font> <font size="-1"><br>
        <br>
        <font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif"><font face="Arial, Helvetica, sans-serif" color="#000080">Not 
        only as a nod to object oriented programming, but also because makes it 
        easier to navigate in large programs, it is better to name procedures 
        and variables in &quot;inverted language&quot;, 
        meaning that you commence with the &quot;class name&quot;, and then, if 
        applicable, indicate the &quot;sub class&quot; and end with specifying 
        your action. For instance, it makes it easier to name your clipboard handling 
        procedure as </font><font color="#000000" face="Courier New, Courier, monospace">ClipboardStringWrite:(aString$)</font><font face="Arial, Helvetica, sans-serif" color="#000080">rather 
        than </font><font face="Courier New, Courier, mono">WriteStringToClipboard:(aString$<font color="#000080">)</font></font><font face="Arial, Helvetica, sans-serif" color="#000080">. 
        The former is easier to find, though of course the latter flows better 
        as human language.</font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></p>    </td>
  </tr>
  <tr valign="top">
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0013"></a></b>dpNote 
      0013<br>
      </font></b><font color="#000080"><br>
      4 Sep 2002<br>
      (Modified 25 October 2004)<br>
      <br>
      All OPL versions </font></font></td>
    <td width="700"> 
      <p><b><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">Conversions 
        between large Hexadecimal and Decimal numbers<br>
        <br>
        </font></b><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">The 
        typical way to obtain a string with hexadecimal representation of a number 
        is <font face="Courier New, Courier, mono" color="#000000">HEX$(&amp;nnnnnnnn)</font>. 
        This only works for hexadecimal numbers up to <font face="Courier New, Courier, mono" color="#000000">&amp;ffffffff</font>. 
        <br>
        <br>
        Converting to decimal representation of a hexadecimal number can be done 
        via <font face="Courier New, Courier, mono" color="#000000">EVAL(&quot;&amp;&quot;+&quot;nnnnnnnn&quot;)</font>, 
        but this method will only work up to <font face="Courier New, Courier, mono" color="#000000">&amp;3fffffff</font> 
        since the <font face="Courier New, Courier, mono" color="#000000">EVAL</font> 
        function interpretes a the <font face="Courier New, Courier, mono" color="#000000">&amp;nnnnnnnn</font> 
        expression as a signed hexadecimal number.<br>
        <br>
        The following two procedures will work with up to 16 digits in decimal 
        format and up to 13 digits in hexadecimal unsigned format. An additional 
        advantage is that they both receive and return the numbers as strings.</font><br>
        <font face="Arial, Helvetica, sans-serif" size="-1" color="#000080"><br>
        Take note that, as the procedures are written here, they will not accept 
        any impurities, e.g. strings with signs, points or exponents, so these 
        elements will have to be cleared out beforehand.</font><br>
        <br>
        <font face="Courier New, Courier, mono" size="-1" color="#000000">PROC 
        CvHexFromDec$:(aDecString$)<br>
        // safe to use for up to 13 significant hex digits<br>
        // and 16 significant dec digits<br>
        LOCAL HexString$(KMaxStringLen%)<br>
        LOCAL value,residue<br>
        // convert from lowest significant while shifting downwards<br>
        value=EVAL(aDecString$)<br>
        HexString$=&quot;&quot;<br>
        DO<br>
        &nbsp;&nbsp;value=value/16.0<br>
        &nbsp;&nbsp;residue=(value-INTF(value))*16.0<br>
        &nbsp;&nbsp;value=INTF(value)<br>
        &nbsp;&nbsp;HexString$=HEX$(residue)+HexString$<br>
        UNTIL value=0<br>
        IF LEN(HexString$)&gt;13<br>
        &nbsp;&nbsp;RAISE KErrOverflow%<br>
        ENDIF<br>
        RETURN HexString$<br>
      ENDP<br>
        <br>
        </font><font face="Courier New, Courier, mono" size="-1" color="#000000">PROC 
        CvDecFromHex$:(aHexString$)<br>
        // safe to use for up to 13 significant hex digits<br>
        // and 16 significant dec digits<br>
        LOCAL value,i%,len%<br>
        len%=LEN(aHexString$)<br>
        IF len%&lt;=7<br>
&nbsp;&nbsp;// if HexString smaller than 8 digits a faster method can 
        be used<br>
&nbsp;&nbsp;value=EVAL(&quot;&amp;&quot;+aHexString$)<br>
ELSEIF len%&lt;=13<br>
&nbsp;&nbsp;// convert one by one and shift upwards<br>
&nbsp;&nbsp;i%=len%<br>
&nbsp;&nbsp;value=0<br>
&nbsp;&nbsp;DO<br>
&nbsp;&nbsp;&nbsp;&nbsp;value=value*16.0+EVAL(&quot;$&quot;+MID$(aHexString$,len%-i%+1,1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;i%=i%-1<br>
&nbsp;&nbsp;UNTIL i%&lt;1<br>
        ELSE<br>
&nbsp;&nbsp;RAISE KErrOverflow%<br>
        ENDIF<br>
        RETURN GEN$(value,16)<br>
        ENDP<br>
        <br>
      </font></p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0014" id="dpNote0014"></a></b>dpNote 0014<br>
      <br>
    </font></b><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">12 Aug 2005<br>
    <br>
    All OPL versions </font></font></font></td>
    <td><p><b><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">Useful POKEs and PEEKs <br>
          <br>
      </font></b><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">Whereas memory shortage shouldn't be a problem with OPL applications, sometimes you might, for one reason or another, like to not use a full byte for storing one single boolean. </font><br>
          <br>
          <font face="Courier New, Courier, mono" size="-1" color="#000000">PROC PokeBoolean:(aPointer&amp;,aBooleanB%)<br>
  // used to reduce space needed for a boolean value in a descriptor<br>
  // KTrue% will be stored as $ff and KFalse% will be stored as $00 <br>
        POKEB aPointer&amp;,(aBooleanB% AND $ff) <br>
  ENDP<br>
  <br>
  PROC PeekBooleanB%:(aPointer&amp;)<br>
  // used to PEEK a boolean value stored with PokeBoolean<br>
  RETURN NOT (PEEKB(aPointer%)=$00)<br>
  ENDP<br>
  </font><font face="Courier New, Courier, mono" color="#000000"><font size="-1" face="Courier New, Courier, monospace"><br>
  </font></font><font size="-1" face="Courier New, Courier, monospace">PROC PeekBitB%:(aByte%,aBit%)<br>
  // tests a single bit if true or not<br>
  // bits are numbered from 0(LSB)..7(MSB)<br>
  RETURN (aByte%=($02**aBit%))<br>
  ENDP</font><br>
    <br>
    <font size="-1" face="Courier New, Courier, monospace">PROC PokeBit:(_Byte&amp;,aBit%,aStateB%)<br>
        // sets or unsets a bit between 0..7<br>
        LOCAL Byte%,ShiftedBit%<br>
        ShiftedBit%=$02**aBit%<br>
        Byte%=PeekWordLE&amp;:(_Byte&amp;)<br>
        // first make sure it's set regardless of desired state<br>
        Byte%=(Byte% OR ShiftedBit%)<br>
        // then invert it if it should be unset<br>
        IF NOT aStateB%<br>
&nbsp;&nbsp;Byte%=Xor&amp;:(Byte%,ShiftedBit%) // ER5<br> 
&nbsp;&nbsp;rem Byte%=SyXor&amp;:(Byte%,ShiftedBit%) // ER6 and later <br>
        ENDIF<br>
        // return<br>
        PokeWordLE:(_Byte&amp;,Byte%)<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0015" id="dpNote0015"></a></b>dpNote 0015<br>
            <br>
    </font></b><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">30</font><font color="#000080"> April 2007<br>
    <br>
All OPL versions</font></font></font></td>
    <td><p><b><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">Endianism <br>
        <br>
      </font></b><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">The following POKEs and PEEK are useful for the handling of Unicode characters, which, depending on the origin of the text file, can be stored either as big or little endian. </font><br>
      <br>
      <font face="Courier New, Courier, mono" size="-1" color="#000000"> PROC PokeCharBE:(aPointer&amp;,aChar16&amp;)<br>
        // POKEs a 2 byte Unicode character as big endian<br>
        POKEB aPointer&amp;,((aChar16&amp; AND &amp;ff00)/&amp;0100)<br>
        POKEB (aPointer&amp;+&amp;1),(aChar16&amp; AND &amp;00ff)<br>
        ENDP<br>
  <br>
        PROC PeekCharBE&amp;:(aPointer&amp;)<br>
        // PEEKs a 2 byte Unicode character as big endian<br>
        RETURN (PEEKB(aPointer&amp;)*&amp;0100) OR PEEKB(aPointer&amp;+&amp;1)<br>
        ENDP<br>
  <br>
        PROC PokeCharLE:(aPointer&amp;,aChar16&amp;)<br>
        // POKEs a 2 byte Unicode character as little endian<br>
        POKEB aPointer&amp;,(aChar16&amp; AND &amp;00ff)<br>
        POKEB (aPointer&amp;+&amp;1),((aChar16&amp; AND &amp;ff00)/&amp;0100)<br>
        ENDP<br>
  <br>
        PROC PeekCharLE&amp;:(aPointer&amp;)<br>
        // PEEKs a 2 byte Unicode character as little endian<br>
        RETURN PEEKB(aPointer&amp;)OR (PEEKB(aPointer&amp;+&amp;1)*&amp;0100)<br>
    ENDP<br>
    <br>
    </font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">And finally this simple function converts Little to Big Endian and vice verse. </font><br>
    <font face="Courier New, Courier, mono" size="-1" color="#000000"><br>
    PROC CvEndianSwitch&amp;:(aChar16&amp;)<br>
    RETURN ((aChar16&amp; AND &amp;ff00)/&amp;0100) OR ((aChar16&amp; AND &amp;00ff)*&amp;0100)<br>
    ENDP</font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0016"></a></b>dpNote 
      0016<br>
      <br>
      </font></b><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">6</font><font color="#000080"> 
      Sep 2004<br>
      <br>
      v5 Eikon
      </font></font></font></td>
    <td width="700"> <b><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">Toolbar 
      buttons with text only</font></b><br>
      <font face="Courier New, Courier, mono" size="-1" color="#000000"><br>
      <font face="Arial, Helvetica, sans-serif" color="#000080">The following 
      code is a workaround for creating Toolbar buttons without a bitmap. If a 
      bitmap is not declared when using Toolbar this causes empty boxes to be 
      displayed on devices like Psion Series 5 and Psion netBook. The trick is 
      to use an empty bitmap.<br>
      </font><br>
      PROC BitMapZeroCreate&amp;:<br>
      // Returns handle to empty bitmap to be used in TBarButt<br>
      LOCAL ZeroBM&amp;<br>
      // clearer to go via variable, coz gCREATEBIT returns short int<br>
      ZeroBM&amp;=gCREATEBIT(0,0)<br>
      RETURN ZeroBM&amp;<br>
      ENDP<br>
      <br>
      </font><font face="Arial, Helvetica, sans-serif" size="-1" color="#000080">and 
        then:<br>
      <br>
      <font face="Courier New, Courier, mono" color="#000000">PROC main:</font><br>
      </font><font face="Courier New, Courier, mono" size="-1" color="#000000">GLOBAL 
        GZeroBM&amp;<br>
      .<br>
      .<br>
      GZeroBM&amp;=BitMapZeroCreate&amp;:<br>
      .<br>
      .<br>
      // in toolbar initialisation routine<br>
      TBarButt:(&quot;a&quot;,1,&quot;Welcome&quot;,0,GZeroBM&amp;,GZeroBM&amp;,0)<br>
      .<br>
      .<br>
      // in exit routine<br>
      gCLOSE GZeroBM&amp;</font></td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0017"></a></b>dpNote 
      0017<br>
      <br>
      </font></b><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">15 
      March 2004<br>
      (updated 11 August 2004)<br>
      <br>
      v5 <font size="-2">(only Psion Teklogix netBook and Psion Series&nbsp;7)</font></font></font></font></td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font size="-1"><b><font size="-1"><b><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">dpToolbar 
        - a better Toolbar for Psion Teklogix netBook and Psion Series 7</font></b></font></b></font></b></font><font color="#000080"><br>
        </font></b><font size="-1"><font color="#000080"><br>
        dpToolbar is, what we hope, an improved Toolbar for the VGA colour screen 
        Psions. It is meant to be used as an OPL programming tool. It adds the 
        following features compared to the built in Toolbar:<br>
        <br>
        1. Fix of the battery symbol bug - the battery symbol is now drawn, so 
        no MBMs are needed.<br>
        <br>
        2. Fix of the 6th button latch bug. In the orginal Toolbar, the 6th button 
        does not latch properly. Now it does.<br>
        <br>
        3. Ability to toggle the toolbar between left and right side of screen. 
        In fact this feature was the original reason why we developed dpToolbar.<br>
        <br>
        4. Fix of the undefined button selection bug - which previously could 
        create hanging<br>
        <br>
        5. Battery background turns red when its time to change backup battery. 
        With the original Toolbar, nothing actually happens with the battery symbol 
        when the backup battery needs to be replaced, even though one can see 
        from the code that some action was intended. Now the background around 
        the battery symbol turns red when the backup battery needs to be replaced.<br>
        <br>
        6. When clicking on the battery symbol on the dpToolbar, the system battery 
        window will instantly be brought to the foreground.<br>
        <br>
        7. The battery is updated with higher precision than the original Toolbar, 
        the latter only having four levels.<br>
        <br>
        8. dpToolbar is now fully backwards compatible with the original Toolbar. 
        <br>
        <br>
        9. dpToolbar is now fully compatible with Andrew Gregory's Toolbar Patcher.<br>
        <br>
        10. dpToolbar can now display Robin Hood's MoonClock. It will detect if 
        MoonClock is installed, locate the mbm-file and display the phase of the 
        moon based on the current date.<br>
        <br>
        11. A small yellow arrow is now shown when external power is connected.<br>
        <br>
        12. In the original Toolbar, only some actions will trigger a battery 
        status update. Now all actions will.<br>
        <br>
        <u>dpToolbar battery status</u><br>
        <br>
        <img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/FullMainWithExternal.jpg" width="70" height="24" align="absmiddle">&nbsp;&nbsp;The 
        main battery is full and the external power source is connected.<br>
        <br>
        <img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/EmptyMain.jpg" width="70" height="24" align="absmiddle">&nbsp;&nbsp;The 
        main battery is empty and there is no external power source.<br>
        <br>
        <img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/NoMainButExternal.jpg" width="70" height="24" align="absmiddle">&nbsp;&nbsp;The 
        main battery has been removed, but the external power source is connected.<br>
        <br>
        <img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/Charging.jpg" width="70" height="24" align="absmiddle">&nbsp;&nbsp;The 
        main battery has been reinserted and is recharging from external power.<br>
        <br>
        <img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/EmptyBackup.jpg" width="70" height="24" align="absmiddle"> 
        &nbsp;The backup battery is empty or removed. Insert a fresh backup battery 
        as soon as possible.<br>
        <br>
        <u> Location and use of dpToolbar files</u><br>
        <br>
        dpToolbar comprises of two files.<br>
        <br>
        1. </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">Toolbar.opo</font></font></font></font><font color="#000080"> 
        should be placed into </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">X:System\Opl\</font>, 
        where <font face="Courier New, Courier, mono" color="#000000">X</font> 
        can be either <font face="Courier New, Courier, mono" color="#000000">C</font> 
        or <font face="Courier New, Courier, mono" color="#000000">D</font>. </font></font></font><font color="#000080"><br>
        <br>
        2. </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">Toolbar.oph<font face="Arial, Helvetica, sans-serif" color="#000080"> 
        </font></font></font></font></font></font></font><font color="#000080">should 
        always be placed in <font face="Courier New, Courier, mono" color="#000000">X:System\Opl\</font></font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080">, 
        where <font face="Courier New, Courier, mono" color="#000000">X</font> 
        can be either <font face="Courier New, Courier, mono" color="#000000">C</font> 
        or <font face="Courier New, Courier, mono" color="#000000">D</font>. </font></font></font></font></font><font color="#000080"><br>
        <br>
        You must also modify the include statement in the application to:<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000000" face="Courier New, Courier, mono">INCLUDE 
        &quot;Toolbar.oph&quot;</font><font color="#000080"><br>
        </font></font></font><font color="#000080"> <br>
        dpToolbar can now be used exactly like the original Toolbar. However to 
        cover all options you should use the following routine to load dpToolbar:<br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">CONST KPathAlternative1$=&quot;C:\System\Opl\Toolbar.opo&quot;<br>
        CONST KPathAlternative2$=&quot;D:\System\Opl\Toolbar.opo&quot;<br>
        CONST KPathAlternative3$=&quot;E:\System\Opl\Toolbar.opo&quot; </font><br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">IF EXIST(KPathAlternative1$)<br>
        &nbsp;&nbsp;Message:(&quot;Loaded: &quot;+KPathAlternative1$)<br>
        &nbsp;&nbsp;LOADM KPathAlternative1$<br>
        ELSEIF EXIST(KPathAlternative2$)<br>
        &nbsp;&nbsp;Message:(&quot;Loaded: &quot;+KPathAlternative2$)<br>
        &nbsp;&nbsp;LOADM KPathAlternative2$<br>
        ELSEIF EXIST(KPathAlternative3$)<br>
        &nbsp;&nbsp;Message:(&quot;Loaded: &quot;+KPathAlternative3$)<br>
        &nbsp;&nbsp;LOADM KPathAlternative3$<br>
        ELSE<br>
        &nbsp;&nbsp;Message:(&quot;Toolbar.opo not found&quot;,&quot;Error in 
        loading&quot;,&quot;See instructions! &quot;)<br>
        &nbsp;&nbsp;PAUSE 40 :STOP<br>
        ENDIF <br>
        TBarLink:(&quot;Main&quot;)</font><br>
        <br>
        <u>OPXs</u><br>
        <br>
        dpToolbar will also need to have <font face="Courier New, Courier, mono" color="#000000">Date.opx</font>, 
        <font color="#000000"> <font face="Courier New, Courier, mono">System.opx</font></font>, 
        <font color="#000000"> <font face="Courier New, Courier, mono">SysRam.opx</font></font> 
        and <font face="Courier New, Courier, mono" color="#000000">SystInfo.opx</font> 
        installed.<br>
        <br>
        <u>Public Procedures</u><br>
        <br>
        The following is a list of public procedures of dpToolbar. There are some 
        additions.<br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">// Public procedures<br>
        EXTERNAL TBarLink:(aAppLink$)<br>
        EXTERNAL TBarInit:(aTitle$,aScreenW%,aScreenH%)<br>
        EXTERNAL TBarInitC:(aTitle$,aScreenW%,aScreenH%,aWindowMode%)<br>
        EXTERNAL TBarInitNonStd:(aName$,aScreenW%,aScreenH%,aWidth%)<br>
        EXTERNAL TBarSetTitle:(aName$)<br>
        EXTERNAL TBarButt:(aShortCut$,aPos%,aText$,aState%,aBitmap&amp;,aMask&amp;,aFlags%)<br>
        EXTERNAL TBarOfferB%:(aWID&amp;,aPtrType&amp;,aPtrX&amp;,aPtrY&amp;)<br>
        EXTERNAL TBarLatch:(aComponent%)<br>
        EXTERNAL TBarShow:<br>
        EXTERNAL TBarHide:<br>
        EXTERNAL TBarOrientationLeft: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REM 
        // added in dpToolbar<br>
        EXTERNAL TBarOrientationRight: </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></font></font></font><font face="Courier New, Courier, mono" color="#000000">REM 
        // added in dpToolbar<br>
        EXTERNAL TBarColour:(aFgR%,aFgG%,aFgB%,aBgR%,aBgG%,aBgB%)<br>
        EXTERNAL TBarIndicators: </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></font></font></font>&nbsp;&nbsp;<font face="Courier New, Courier, mono" color="#000000">REM 
        // rewritten in dpToolbar<br>
        EXTERNAL TBarDpVersion$: </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></font></font></font>&nbsp;&nbsp;<font face="Courier New, Courier, mono" color="#000000">REM 
        // added in dpToolbar</font><br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">TBarOrientationLeft:</font></font></font></font> 
        <font color="#000080">will orient the Toolbar to the left side of the 
        screen instead of the right. This is of importance for some work situations 
        when the right hand is occupied or when the overall screen layout so demands 
        it. Several of DP applications, for instance dpCalc, make 
        use of this function.<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">TBarOrientationRight:</font></font></font></font><font color="#000080"> 
        will orient the Toolbar back to the right side of the screen.<br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">TBarIndicators:</font></font></font></font> 
        <font color="#000080">will now update both the battery information and 
        check the backup battery.<br>
        <br>
        <u>Public Variables</u><br>
        <br>
        The following globals are available for the application:<br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">TbWidth%</font> 
        holds the pixel width of the toolbar.<br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">TbVisibleB%</font> 
        carries the value <font face="Courier New, Courier, mono" color="#000000">KTrue%</font> 
        if visible and otherwise <font face="Courier New, Courier, mono" color="#000000">KFalse%</font>. 
        Take note that according to DP  coding norms, a boolean variable 
        name ends with <font face="Courier New, Courier, mono" color="#000000">B%</font>. 
        This is a change compared to the original Toolbar.<br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">TbRightB%</font> 
        has the value <font face="Courier New, Courier, mono" color="#000000">KTrue%</font> 
        if the Toolbar is right oriented and<font face="Courier New, Courier, mono" color="#000000"> 
        KFalse%</font> if it is left oriented. This is a new variable. </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">TBarOrientationLeft:</font></font></font></font></font></font> 
        <font color="#000080">and</font> <font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">TBarOrientationRight:</font></font></font></font></font></font> 
        <font color="#000080">will automatically set </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">TbRightB%</font></font></font></font><font color="#000080"> 
        accordingly, so </font></font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080"><font face="Courier New, Courier, mono" color="#000000">TbRightB%</font></font></font><font color="#000080"> 
        should only be <b>tested</b>, not modified, by the application.</font></font><font size="-1"><font color="#000080"><br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">TbMenuSym%</font> 
        carries the current 'Show toolbar' menu symbol (to be OR:ed with shortcut 
        letter). This has not been changed since the original Toolbar.<br>
        <br>
        <font face="Courier New, Courier, mono" color="#000000">TbWID%</font> 
        holds the Toolbar Window ID. Take note of the name change. DP 
        always uses <font color="#000000"> <font face="Courier New, Courier, mono">WID%</font></font> 
        to denote a window ID variable.<br>
        <br>
        <u>Files and demo application</u><br>
        <br>
        The files are <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/Downloadables.htm">downloadable here</a> together 
        with a simple demonstration application. Running the demo application, 
        pressing Ctrl+T will toggle between left and right. <br>
        <br>
        This is dpCalc with the Toolbar oriented to the left. The external power 
        is OFF.<br>
        <br>
        <img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/dpCalcLeft.jpg" width="640" height="480" border="0"> 
        <br>
        <br>
        </font></font></font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font color="#000080">This 
        is dpCalc with the Toolbar oriented to the right. The external power is 
        ON:</font></font></font></p>
      <p><img src="http://web.archive.org/web/20080323085741im_/http://opldev.broeze.eu/dpNotes/Assets/dpCalcExt.jpg" width="640" height="480" border="0"></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0018"></a></b>dpNote 
      0018</font></b><font color="#000080"><br>
      <br>
      20 Dec 2002<br>
      <br>
      All OPL versions </font></font></td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Loading 
        a complete file into a buffer<br>
        </font></b></font><font size="-1"><br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">This procedure 
        will load a complete file into a buffer, id est into memory, for further 
        manipulation.</font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">Usage:</font><br>
        <font face="Courier New, Courier, mono">pOutBuffer&amp;</font>=<font face="Courier New, Courier, mono">TextFileLoadIntoBuffer&amp;:(Path$+FileName$)<br>
        <br>
        </font><font color="#000080" face="Arial, Helvetica, sans-serif">The buffer is allocated, which means that it has to be cleaned up later. </font><font face="Courier New, Courier, mono"><br>
        <br>
        INCLUDE &quot;System.oxh&quot;        <br>
        <br>
        CONST KIoReadWriteChunk&amp;=&amp;2000 <br>
        <br>
        </font></font><font face="Courier New, Courier, mono" size="-1">PROC TextFileLoadIntoBuffer&amp;:(aFileName$)<br>
        LOCAL pBuffer&amp;,InFilesize&amp;<br>
        LOCAL hInfile%,IoMode%,r%,IoReturn&amp;<br>
        // allocate buffer according to file size<br>
        InFilesize&amp;=SyFileSize&amp;:(aFileName$)<br>
        Message:(&quot;Filesize: &quot;+GEN$(InFilesize&amp;,12))<br>
        pBuffer&amp;=ALLOC(InFilesize&amp;+KIoReadWriteChunk&amp;) // give ample additional space <br>
        // load text file into the buffer<br>
        IoMode%=KIoModeOpen% OR KIoFormatBinary% OR KIoAccessRandom%<br>
        IOOPEN(hInfile%,aFileName$,IoMode%)<br>
        r%=0<br>
        DO<br>
        &nbsp;&nbsp;IoReturn&amp;=IOREAD(hInfile%,pBuffer&amp;+r%*KIoReadWriteChunk&amp;,KIoReadWriteChunk&amp;)<br>
        &nbsp;&nbsp;r%=r%+1<br>
        &nbsp;&nbsp;BUSY GEN$(r%,6)<br>
        UNTIL IoReturn&amp;&lt;&gt;KIoReadWriteChunk&amp;<br>
        BUSY OFF<br>
        IOCLOSE(hInfile%)<br>
        RETURN pBuffer&amp;<br>
        ENDP<br>
         <br>
        PROC Message:(aMsg$)<br>
        gIPRINT aMsg$,KBusyTopRight%<br>
        ENDP<br>
        </font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080"><b><a name="dpNote0019"></a></b>dpNote 
      0019</font></b><font color="#000080"><br>
      <br>
      21 Dec 2002<br>
      <br>
      v6 Series 80 R1 </font></font></td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"><b>Converting 
        long text buffers between Unicode and Ascii</b><br>
        <br>
        These two procedures are useful when you have read a text file into a 
        binary buffer, for instance using the routine described in <b><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0018">dpNote 
        0018</a></b>, and wish to covert it to either Unicode or Ascii format.<br>
        <br>
        For conversion from Unicode to Ascii, the usage is:</font><font size="-1"><br>
        <br>
        <font face="Courier New, Courier, mono">CvUnicodeToAscii:(ADDR(pBuffer&amp;),ADDR(BufferSize&amp;))</font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">For conversion 
        from Ascii to Unicode, the usage is</font><br>
        <br>
        <font face="Courier New, Courier, mono">CvAsciiToUnicode:(ADDR(pBuffer&amp;),ADDR(BufferSize&amp;))</font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">The procedures 
        require the <font color="#000000" face="Courier New, Courier, monospace">Buffer.opx</font> and the <font color="#000000" face="Courier New, Courier, monospace">Convert.opx</font>.</font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">Also take note 
        that a real program should have out of memory error handling.</font><br>
        <br>
        <font face="Courier New, Courier, mono">INCLUDE &quot;Buffer.oxh&quot;<br>
        INCLUDE &quot;Convert.oxh&quot;<br>
        INCLUDE &quot;Const.oph&quot;<br>
        <br>
        PROC CvUnicodeToAscii:(_pBuffer&amp;,_BufferSize&amp;)<br>
        // this routine converts Unicode text in a binary buffer apSource&amp; 
        to<br>
        // a buffer with the same text in Ascii. The size of the resulting<br>
        // buffer is half that of the original buffer<br>
        LOCAL SourceSize&amp;,SourceLength&amp;,pSource&amp;,TargetSize&amp;,TargetLength&amp;,pTarget&amp;<br>
        LOCAL ChunkLength&amp;,pIn&amp;,pOut&amp;<br>
        // obtain BYREF values<br>
        pSource&amp;=PEEKL(_pBuffer&amp;)<br>
        SourceSize&amp;=PEEKL(_BufferSize&amp;)<br>
        // get size of source buffer and calculate length<br>
        // using LENALLOC(pSource&amp;) will give word alignment error
        <br>
        SourceLength&amp;=SourceSize&amp;/KUnicodeFactor%<br>
        // the size of the target buffer is half of that of the source buffer<br>
        TargetLength&amp;=SourceLength&amp;<br>
        TargetSize&amp;=TargetLength&amp;<br>
        // allocate the target buffer<br>
        pTarget&amp;=ALLOC(TargetSize&amp;)<br>
        IF pTarget&amp;=0 :RAISE KErrNoMemory% :ENDIF<br>
        // the Convert opx only allows conversion of 255 characters at a time<br>
        ChunkLength&amp;=KMaxStringLen%<br>
        // initialise pointers<br>
        pIn&amp;=pSource&amp;<br>
        pOut&amp;=pTarget&amp;<br>
        // convert 255 characters at a time<br>
        WHILE (pIn&amp;-pSource&amp;)&lt;=(SourceSize&amp;-KMaxStringLen%*KUnicodeFactor%)<br>
        &nbsp;&nbsp;CvFromUnicode:(pOut&amp;,ChunkLength&amp;,BufferAsString$:(pIn&amp;,ChunkLength&amp;))<br>
        &nbsp;&nbsp;// the source buffer pointer is offset 2 times more than the 
        target<br>
        &nbsp;&nbsp;pIn&amp;=pIn&amp;+ChunkLength&amp;*KUnicodeFactor%<br>
        &nbsp;&nbsp;pOut&amp;=pOut&amp;+ChunkLength&amp;<br>
        &nbsp;&nbsp;// check if the pointer is closer than 255 chars to the end 
        of buffer<br>
        ENDWH<br>
        // handle the remaining chunk<br>
        ChunkLength&amp;=(SourceSize&amp;-(pIn&amp;-pSource&amp;))/KUnicodeFactor%<br>
        CvFromUnicode:(pOut&amp;,ChunkLength&amp;,BufferAsString$:(pIn&amp;,ChunkLength&amp;))<br>
        // free up the source buffer<br>
        FREEALLOC pSource&amp;<br>
        // return BYREF values passed by reference <br>
        POKEL _pBuffer&amp;,pTarget&amp;<br>
        </font><font size="-1"><font face="Courier New, Courier, mono">POKEL _BufferSize&amp;,TargetSize&amp;</font></font><font face="Courier New, Courier, mono"><br>
        ENDP</font></font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC CvAsciiToUnicode:(_pBuffer&amp;,_BufferSize&amp;)<br>
        // this routine converts Ascii text in a buffer apSource&amp; to<br>
        // a buffer with the same text in Unicode. The size of the resulting<br>
        // buffer is double that of the original buffer<br>
        // i.e. TargetSize&amp;=aSourceSize&amp;*KUnicodeFactor%<br>
        LOCAL SourceSize&amp;,SourceLength&amp;,pSource&amp;,TargetSize&amp;,TargetLength&amp;,pTarget&amp;<br>
        LOCAL ChunkLength&amp;,pIn&amp;,pOut&amp;<br>
        </font><font size="-1"><font face="Courier New, Courier, mono">// obtain BYREF values<br>
pSource&amp;=PEEKL(_pBuffer&amp;)<br>
SourceSize&amp;=PEEKL(_BufferSize&amp;)</font></font><font face="Courier New, Courier, mono" size="-1"><br>
        // get size of source buffer and calculate length<br>
        SourceSize&amp;=aSourceSize&amp; <br>
        SourceLength&amp;=aSourceSize&amp;<br>
        // the size of the target buffer is double that of the source buffer<br>
        TargetLength&amp;=SourceLength&amp;<br>
        TargetSize&amp;=TargetLength&amp;*KUnicodeFactor%<br>
        // allocate the target buffer<br>
        pTarget&amp;=ALLOC(TargetSize&amp;)<br>
        IF pTarget&amp;=0 :RAISE KErrNoMemory% :ENDIF <br>
        // the convert opx only allows to conversion of 255 characters at a time<br>
        ChunkLength&amp;=KMaxStringLen%<br>
        // initialise pointers<br>
        pIn&amp;=pSource&amp;<br>
        pOut&amp;=pTarget&amp;<br>
        // convert 255 characters at a time<br>
        WHILE (pIn&amp;-pSource&amp;)&lt;=(SourceSize&amp;-KMaxStringLen%)<br>
&nbsp;&nbsp;BufferFromString&amp;:(pOut&amp;,ChunkLength&amp;,CvUnicode$:(pIn&amp;,ChunkLength&amp;))<br>
&nbsp;&nbsp;// the target buffer pointer is offset 2 times more than the 
        source<br>
&nbsp;&nbsp;pIn&amp;=pIn&amp;+ChunkLength&amp;<br>
&nbsp;&nbsp;pOut&amp;=pOut&amp;+ChunkLength&amp;*KUnicodeFactor%<br>
&nbsp;&nbsp;// check if the pointer is closer than 255 chars to the end 
        of buffer<br>
        ENDWH<br>
        // handle the remaining chunk<br>
        ChunkLength&amp;=(SourceSize&amp;-(pIn&amp;-pSource&amp;))<br>
        BufferFromString&amp;:(pOut&amp;,ChunkLength&amp;,CVUnicode$:(pIn&amp;,ChunkLength&amp;))<br>
        // free up the source buffer<br>
        FREEALLOC pSource&amp;        <br>
</font><font size="-1"><font face="Courier New, Courier, mono">// return values passed by reference <br>
POKEL _pBuffer&amp;,pTarget&amp;</font></font><font face="Courier New, Courier, mono" size="-1"><br>
POKEL _BufferSize&amp;,TargetSize&amp; <br>
        ENDP<br>
        <br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">Convention: 
        We always use the word 'length' or 'len' to refer to the length of a string 
        in characters. We always use the word 'size' to refer to a the size of 
        a string in bytes. In ER5 days, there was no apparent difference, so in 
        the documentation of the Buffer.opx, which is unchanged in ER6 and later, sometimes 
        the two terms are confused.</font><br>
    </font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0020"></a></b></font></b><font color="#000080">dpNote 
        0020</font></b></font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">21 Dec 2002<br>
        <br>
        </font></font><font color="#000080">v6 Series 80 R1</font></font></p>    </td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">LOC 
        function which gives correct answer for control and Unicode characters<br>
        </font></b><font color="#000080"><br>
        The <font face="Courier New, Courier, mono" color="#000000">LOC(aString$,aChar$)</font> 
        function in OPL does not work correctly in v6/S80 for control and Unicode 
        characters.<br>
        <br>
        As a workaround, the following procedure can be used. It requires the 
        Buffer OPX. <br>
        <br>
        </font><font size="-1"><font face="Courier New, Courier, mono">INCLUDE 
        &quot;Buffer.oxh&quot;<br>
        INCLUDE &quot;Const.oph&quot;<br>
        <br>
        PROC Loc%:(aString$,aChar$)<br>
        LOCAL String$(KMaxStringLen%),Location%<br>
        String$=aString$<br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Courier New, Courier, mono">Location%=BufferFind&amp;:(ADDR(String$)+KUnicodeHeader%,LEN(String$),aChar$,0)+1</font></font></font><font face="Courier New, Courier, mono"> 
        <br>
        RETURN Location%<br>
        ENDP </font></font><font color="#000080"> <br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">Thanks 
        to Kevin Millican for this idea.</font></font></font></p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0021" id="dpNote0021"></a></b></font></b><font color="#000080">dpNote 
        0021</font></b></font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">21 Dec 2002<br>
        <br>
        </font></font><font color="#000080">All OPL versions </font></font></td>
    <td><font size="-1"><b><font size="-1"><b><font color="#000080" size="-1" face="Arial, Helvetica, sans-serif"><b>Character conversions</b></font></b></font></b></font><br>
      <br>
      <font face="Arial, Helvetica, sans-serif" size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">In <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0019">dpNote 0019</a>, we are converting a text buffer between ASCII and Unicode using the Convert OPX. However, ER1-ER5 programmers do not have the benefit of this OPX. What if I for some reason wish to prepare a Unicode text file in a Psion for later transfer over to a Symbian phone or other Unicode device?<br>
      <br>
      As second issue are those Psion specific characters that are defined between $06 and $10. Those are not part of Code Page 1252 and will not be converted if not handled specifically. Hence these conversion routines are important also for OPL programmers of ER6 and later. What if I want to be able to read Psion generated ASCII files on my Nokia 9500? </font></font></font><font size="-1" face="Courier New, Courier, monospace"><br>
      <br>
      CONST KCvUnicodeCharNotUsed&amp;=&amp;001a<br>
      CONST KCvUnicodeCharNotAvailable&amp;=&amp;001a<br>
      CONST KCvAsciiCharNotUsed%=$1a<br>
      CONST KCvAsciiCharNotAvailable%=$1a<br>
      CONST KUnicodeFactor%=2 <br>
      <br>
      PROC CvCp1252ToUnicode:(_pBuffer&amp;,_Size&amp;)<br>
      // converts a buffer of 1 byte Code Page 1252 characters to a<br>
      // buffer of 2 bytes Unicode characters. The size of the resulting<br>
      // buffer is double that of the original buffer<br>
      // i.e. TargetSize&amp;=aSourceSize&amp;*KUnicodeFactor%<br>
      // assumes that the Unicode characters are stored as Little Endian<br>
      LOCAL pOut&amp;,Size&amp;,Offset&amp;,Word&amp;,Byte%,pIn&amp;<br>
      // acquire BYREF values<br>
      pIn&amp;=PEEKL(_pBuffer&amp;)<br>
      Size&amp;=PEEKL(_Size&amp;)*KUnicodeFactor%<br>
      pOut&amp;=ALLOC(Size&amp;)<br>
      IF pOut&amp;=0 :RAISE KErrNoMemory% :ENDIF<br>
      Offset&amp;=0<br>
      DO<br>
      &nbsp;&nbsp;Byte%=PEEKB(pIn&amp;+Offset&amp;/KUnicodeFactor%)<br>
      &nbsp;&nbsp;// avoid jump for speed purposes<br>
      &nbsp;&nbsp;IF Byte%&gt;=$20 AND Byte%&lt;=$7f<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=Byte%<br>
      &nbsp;&nbsp;ELSE<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=CvAsciiCharToUnicode&amp;:(Byte%)<br>
      &nbsp;&nbsp;ENDIF<br>
      &nbsp;&nbsp;// since POKEW interprets values &gt;&amp;8000 as negative we need to use<br>
      &nbsp;&nbsp;// bytewise pokes, however we can avoid jump if possible for<br>
      &nbsp;&nbsp;// speed purposes<br>
      &nbsp;&nbsp;IF Word&amp;&lt;=&amp;7fff<br>
      &nbsp;&nbsp;&nbsp;&nbsp;POKEW (pOut&amp;+Offset&amp;),Word&amp;<br>
      &nbsp;&nbsp;ELSE<br>
      &nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:((pOut&amp;+Offset&amp;),Word&amp;)<br>
      &nbsp;&nbsp;ENDIF<br>
      &nbsp;&nbsp;Offset&amp;=Offset&amp;+KUnicodeFactor%<br>
      UNTIL Offset&amp;&gt;=Size&amp;<br>
      // cleanup<br>
      FREEALLOC(pIn&amp;)<br>
      // return BYREF values<br>
      POKEL _pBuffer&amp;,pOut&amp;<br>
      POKEL _Size&amp;,Size&amp;<br>
      ENDP<br>
      <br>
      PROC CvUnicodeToCp1252:(_pBuffer&amp;,_Size&amp;)<br>
        // Converts a buffer of 2 bytes Unicode characters to a<br>
        // buffer of 1 byte Code Page 1252 characters<br>
        // assumes that the Unicode characters are stored as Little Endian<br>
        LOCAL pOut&amp;,Size&amp;,Offset&amp;,Byte%,Word&amp;,pIn&amp;<br>
        // acquire BYREF values<br>
        Size&amp;=PEEKL(_Size&amp;)/KUnicodeFactor%<br>
        pIn&amp;=PEEKL(_pBuffer&amp;)<br>
        // allocate buffer - half the size of source buffer<br>
        pOut&amp;=ALLOC(Size&amp;)<br>
        IF pOut&amp;=0 :RAISE KErrNoMemory% :ENDIF<br>
        Offset&amp;=0<br>
        WHILE Offset&amp;&lt;Size&amp;<br>
        &nbsp;&nbsp;Word&amp;=PeekWordLE&amp;:(pIn&amp;+Offset&amp;*KUnicodeFactor%)<br>
        &nbsp;&nbsp;// do fast conversion of common characters for speed purposes<br>
        &nbsp;&nbsp;IF Word&amp;&gt;=&amp;0020 AND Word&amp;&lt;=&amp;007f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=Word&amp;<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=CvUnicodeCharToAscii%:(Word&amp;)<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;POKEB (pOut&amp;+Offset&amp;),Byte%<br>
        &nbsp;&nbsp;Offset&amp;=Offset&amp;+&amp;0001<br>
        ENDWH<br>
        // cleanup<br>
        FREEALLOC(pIn&amp;)<br>
        // return BYREF values<br>
        POKEL _pBuffer&amp;,pOut&amp;<br>
        POKEL _Size&amp;,Size&amp;<br>
      ENDP<br>
      <br>
      PROC CvUnicodeToPsion:(_pBuffer&amp;,_Size&amp;)<br>
        // converts a buffer of 2 bytes Little Endian Unicode characters to<br>
        // a buffer of 1 byte Psion Code Page 1252 characters<br>
        //<br>
        // 	KNonBreakingTabER5%=$0a is not supported in Unicode<br>
        //<br>
        LOCAL pInStart&amp;,pOutStart&amp;,Size&amp;,Offset&amp;,Word&amp;,Byte%<br>
        // aquire BYREF values<br>
        pInStart&amp;=PEEKL(_pBuffer&amp;)<br>
        Size&amp;=PEEKL(_Size&amp;)/KUnicodeFactor%<br>
        // prepare outbuffer<br>
        pOutStart&amp;=ALLOC(Size&amp;)<br>
        IF pOutStart&amp;=0 :RAISE KErrNoMemory% :ENDIF<br>
        // convert<br>
        Offset&amp;=0<br>
        WHILE Offset&amp;&lt;Size&amp;<br>
        &nbsp;&nbsp;Word&amp;=PeekWordLE&amp;:(pInStart&amp;+Offset&amp;*KUnicodeFactor%)<br>
        &nbsp;&nbsp;// quick character convert for speed reasons<br>
        &nbsp;&nbsp;IF Word&amp;&gt;=&amp;0020 AND Word&amp;&lt;=&amp;007f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=Word&amp;<br>
        &nbsp;&nbsp;// Psion special characters start here<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KParagraphEnd&amp;                 // $2029<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KParagraphEndER5%                   // $06<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KLineBreak&amp;                    // $2028<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KLineBreakER5%                      // $07<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KPageBreak&amp;                    // $000c<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KPageBreakER5%                      // $08<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KTabCharacter&amp;                 // $0009<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KTabCharacterER5%                   // $09<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KNonBreakingHyphen&amp;            // $2011<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KNonBreakingHyphenER5%              // $0b <br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KPotentialHyphen&amp;              // $00ad<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KPotentialHyphenER5%                // $0c<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KCarriageReturn&amp;               // &amp;000d<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KCarriageReturnER5%                 // $0d<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KPictureCharacter&amp;             // $fffc<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KPictureCharacterER5%               // $0e<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=&amp;2027                          // Hyphenation point<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KVisibleSpaceCharacterER5%          // $0f<br>
        &nbsp;&nbsp;ELSEIF Word&amp;=KNonBreakingSpace&amp;             // $00a0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=KNonBreakingSpaceER5%               // $10<br>
        &nbsp;&nbsp;// all other characters<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Byte%=CvUnicodeCharToAscii%:(Word&amp;)<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;POKEB (pOutStart&amp;+Offset&amp;),Byte%<br>
        &nbsp;&nbsp;Offset&amp;=Offset&amp;+&amp;1<br>
        ENDWH<br>
        // cleanup<br>
        FREEALLOC(pInStart&amp;)<br>
        // return BYREF values<br>
        POKEL _pBuffer&amp;,pOutStart&amp;<br>
        POKEL _Size&amp;,Size&amp;<br>
      ENDP<br>
      <br>
      PROC CvPsionToUnicode:(_pBuffer&amp;,_Size&amp;)<br>
        // converts a buffer of 1 byte Psion Code Page 1252 characters to a<br>
        // buffer of 2 bytes Unicode characters<br>
        // assumes that the Unicode characters are stored as Little Endian<br>
        LOCAL pIn&amp;,pInCurrent&amp;,pInEnd&amp;,pOut&amp;,pOutCurrent&amp;,Size&amp;,Word&amp;,Byte%,NextByte%<br>
        // aquire BYREF values<br>
        pIn&amp;=PEEKL(_pBuffer&amp;)<br>
        Size&amp;=PEEKL(_Size&amp;)<br>
        pInEnd&amp;=pIn&amp;+Size&amp;<br>
        // prepare outbuffer<br>
        pOut&amp;=ALLOC(Size&amp;*KUnicodeFactor%)<br>
        IF pOut&amp;=0 :RAISE KErrNoMemory% :ENDIF<br>
        // convert<br>
        pInCurrent&amp;=pIn&amp;<br>
        pOutCurrent&amp;=pOut&amp;<br>
        WHILE pInCurrent&amp;&lt;pInEnd&amp;<br>
        &nbsp;&nbsp;Byte%=PEEKB(pInCurrent&amp;)<br>
        &nbsp;&nbsp;// let's do this for speed reasons<br>
        &nbsp;&nbsp;IF Byte%&gt;=$20 AND Byte%&lt;=$7f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=Byte%<br>
        &nbsp;&nbsp;// special Psion characters<br>
        &nbsp;&nbsp;ELSEIF ((Byte%&gt;=$06) AND (Byte%&lt;=$10))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;IF Byte%=KParagraphEndER5%                  // $06<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle the case when we have two $06 after each other<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF ((pInCurrent&amp;+&amp;1)&lt;(pIn&amp;+Size&amp;))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NextByte%=PEEKB(pInCurrent&amp;+&amp;1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NextByte%=$00<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF NextByte%=KParagraphEndER5% <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KParagraphEnd&amp; rem KCarriageReturnER5%    // $000d<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOutCurrent&amp;,Word&amp;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pOutCurrent&amp;=pOutCurrent&amp;+KUnicodeFactor%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KLineBreak&amp; rem KLineFeed&amp;               // $000a<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOutCurrent&amp;,Word&amp;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pOutCurrent&amp;=pOutCurrent&amp;+KUnicodeFactor%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pInCurrent&amp;=pInCurrent&amp;+&amp;2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KParagraphEnd&amp;                    // $2029<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KLineBreakER5%                 // $07<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KLineBreak&amp;                         // $2028<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KPageBreakER5%                 // $08<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KPageBreak&amp;                         // $000c<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KTabCharacterER5%              // $09<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KTabCharacter&amp;                      // $0009<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KNonBreakingTabER5%            // $0a<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KTabCharacter&amp;                      // $0009<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KNonBreakingHyphenER5%         // $0b <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KNonBreakingHyphen&amp;                 // $2011<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KPotentialHyphenER5%           // $0c <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KPotentialHyphen&amp;                   // $00ad<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KCarriageReturnER5%            // $0d<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KCarriageReturn&amp;                    // &amp;000d<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KPictureCharacterER5%          // $0e<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KPictureCharacter&amp;                  // $fffc<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KVisibleSpaceCharacterER5%     // $0f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=&amp;2027 // Hyphenation point<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Byte%=KNonBreakingSpaceER5%          // $10<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KNonBreakingSpace&amp;                  // $00a0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=KCvUnicodeCharNotAvailable&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Word&amp;=CvAsciiCharToUnicode&amp;:(Byte%)<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;// avoid jump if possible for speed purposes<br>
        &nbsp;&nbsp;IF Word&amp;&lt;=&amp;7fff<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEW pOutCurrent&amp;,Word&amp;<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOutCurrent&amp;,Word&amp;)<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;pInCurrent&amp;=pInCurrent&amp;+&amp;1<br>
        &nbsp;&nbsp;pOutCurrent&amp;=pOutCurrent&amp;+KUnicodeFactor%<br>
        ENDWH<br>
        // cleanup<br>
        FREEALLOC(pIn&amp;)<br>
        // return BYREF values<br>
        POKEL _pBuffer&amp;,pOut&amp;<br>
        POKEL _Size&amp;,(Size&amp;*KUnicodeFactor%)<br>
      ENDP<br>
      <br>
      PROC CvAsciiCharToUnicode&amp;:(aAsciiChar%)<br>
        // this should be according to charset Code Page 1252 but we have not<br>
        // fully verified this. This can be done in a Unicode machine<br>
        IF aAsciiChar%&lt;=$7f AND aAsciiChar%&gt;=$00<br>
        &nbsp;&nbsp;RETURN aAsciiChar%<br>
        ELSEIF aAsciiChar%=$ad // &quot;&shy;&quot; (in)visible soft hyphen<br>
        &nbsp;&nbsp;RETURN &amp;00ad // soft hyphen<br>
        ELSEIF aAsciiChar%&gt;=$a0 AND aAsciiChar%&lt;=$ff<br>
        &nbsp;&nbsp;RETURN aAsciiChar%<br>
        ELSEIF aAsciiChar%=$80 // &quot;&euro;&quot; euro<br>
        &nbsp;&nbsp;RETURN &amp;20ac<br>
        ELSEIF aAsciiChar%=$81 // not used<br>
        &nbsp;&nbsp;RETURN KCvUnicodeCharNotUsed&amp;<br>
        ELSEIF aAsciiChar%=$82 // &quot;,&quot; single low quotation mark<br>
        &nbsp;&nbsp;RETURN &amp;201a<br>
        ELSEIF aAsciiChar%=$83 // &quot;&fnof;&quot; function f<br>
        &nbsp;&nbsp;RETURN &amp;0192<br>
        ELSEIF aAsciiChar%=$84 // &quot;&bdquo;&quot; double comma<br>
        &nbsp;&nbsp;RETURN &amp;201e<br>
        ELSEIF aAsciiChar%=$85 // &quot;&hellip;&quot; horizontal ellipsis<br>
        &nbsp;&nbsp;RETURN &amp;2026<br>
        ELSEIF aAsciiChar%=$86 // &quot;&dagger;&quot; dagger, long cross<br>
        &nbsp;&nbsp;RETURN &amp;2020<br>
        ELSEIF aAsciiChar%=$87 // &quot;&Dagger;&quot; double dagger<br>
        &nbsp;&nbsp;RETURN &amp;2021<br>
        ELSEIF aAsciiChar%=$88 // &quot;&circ;&quot; modifier letter circumflex accent<br>
        &nbsp;&nbsp;RETURN &amp;02c6<br>
        ELSEIF aAsciiChar%=$89 // &quot;&permil;&quot; permille<br>
        &nbsp;&nbsp;RETURN &amp;2030<br>
        ELSEIF aAsciiChar%=$8a // &quot;&Scaron;&quot; latin capital letter s with caron<br>
        &nbsp;&nbsp;RETURN &amp;0160<br>
        ELSEIF aAsciiChar%=$8b // &quot;&lsaquo;&quot; single left-pointing angle quotation mark<br>
        &nbsp;&nbsp;RETURN &amp;2039<br>
        ELSEIF aAsciiChar%=$8c // &quot;&OElig;&quot; latin capital ligature OE<br>
        &nbsp;&nbsp;RETURN &amp;0152<br>
        ELSEIF aAsciiChar%=$8d // not used<br>
        &nbsp;&nbsp;RETURN KCvUnicodeCharNotUsed&amp;<br>
        ELSEIF aAsciiChar%=$8e // &quot;&#381;&quot; latin capital letter z with caron<br>
        &nbsp;&nbsp;RETURN &amp;017b<br>
        ELSEIF aAsciiChar%=$8f // not used<br>
        &nbsp;&nbsp;RETURN KCvUnicodeCharNotUsed&amp;<br>
        ELSEIF aAsciiChar%=$90 // not used<br>
        &nbsp;&nbsp;RETURN KCvUnicodeCharNotUsed&amp;<br>
        ELSEIF aAsciiChar%=$91 // &quot;&lsquo;&quot; left single quotation mark<br>
        &nbsp;&nbsp;RETURN &amp;2018<br>
        ELSEIF aAsciiChar%=$92 // &quot;&rsquo;&quot; right single quotation mark<br>
        &nbsp;&nbsp;RETURN &amp;2019<br>
        ELSEIF aAsciiChar%=$93 // &quot;&ldquo;&quot; left double quotation mark<br>
        &nbsp;&nbsp;RETURN &amp;201c<br>
        ELSEIF aAsciiChar%=$94 // &quot;&rdquo;&quot; right double quotation mark<br>
        &nbsp;&nbsp;RETURN &amp;201d<br>
        ELSEIF aAsciiChar%=$95 // &quot;&bull;&quot; bullet<br>
        &nbsp;&nbsp;RETURN &amp;2022<br>
        ELSEIF aAsciiChar%=$96 // &quot;&ndash;&quot; en dash<br>
        &nbsp;&nbsp;RETURN &amp;2013<br>
        ELSEIF aAsciiChar%=$97 // &quot;&mdash;&quot; horizontal bar<br>
        &nbsp;&nbsp;RETURN &amp;2015<br>
        ELSEIF aAsciiChar%=$98 // &quot;&tilde;&quot; small tilde<br>
        &nbsp;&nbsp;RETURN &amp;02dc<br>
        ELSEIF aAsciiChar%=$99 // &quot;&trade;&quot; trade mark sign<br>
        &nbsp;&nbsp;RETURN &amp;2122<br>
        ELSEIF aAsciiChar%=$9a // &quot;&scaron;&quot; latin small letter s with caron<br>
        &nbsp;&nbsp;RETURN &amp;0161<br>
        ELSEIF aAsciiChar%=$9b // &quot;&rsaquo;&quot; single right-pointing angle quotation mark<br>
        &nbsp;&nbsp;RETURN &amp;203a<br>
        ELSEIF aAsciiChar%=$9c // &quot;&oelig;&quot; latin small ligature OE<br>
        &nbsp;&nbsp;RETURN &amp;0153<br>
        ELSEIF aAsciiChar%=$9d // not used<br>
        &nbsp;&nbsp;RETURN KCvUnicodeCharNotUsed&amp;<br>
        ELSEIF aAsciiChar%=$9e // &quot;&#382;&quot; latin small letter z with caron<br>
        &nbsp;&nbsp;RETURN &amp;017e<br>
        ELSEIF aAsciiChar%=$9f // &quot;&Yuml;&quot; latin capital letter y with diaeresis<br>
        &nbsp;&nbsp;RETURN &amp;0178<br>
        ELSE<br>
        &nbsp;&nbsp;RETURN KCvUnicodeCharNotUsed&amp;<br>
        ENDIF<br>
      ENDP<br>
      <br>
      PROC CvUnicodeCharToAscii%:(aUnicodeChar&amp;)<br>
    // this should be according to Code Page 1252<br>
        IF aUnicodeChar&amp;&lt;=&amp;007f AND aUnicodeChar&amp;&gt;=&amp;0000<br>
        &nbsp;&nbsp;RETURN aUnicodeChar&amp;<br>
        ELSEIF aUnicodeChar&amp;&gt;=&amp;00a0 AND aUnicodeChar&amp;&lt;=&amp;00ff<br>
        &nbsp;&nbsp;RETURN aUnicodeChar&amp;<br>
        ELSEIF aUnicodeChar&amp;=&amp;0152 // &quot;&OElig;&quot; latin capital ligature OE<br>
        &nbsp;&nbsp;RETURN $8c<br>
        ELSEIF aUnicodeChar&amp;=&amp;0153 // &quot;&oelig;&quot; latin small ligature OE<br>
        &nbsp;&nbsp;RETURN $9c<br>
        ELSEIF aUnicodeChar&amp;=&amp;0160 // &quot;&Scaron;&quot; latin capital letter s with caron<br>
        &nbsp;&nbsp;RETURN $8a<br>
        ELSEIF aUnicodeChar&amp;=&amp;0161 // &quot;&scaron;&quot; latin small letter s with caron<br>
        &nbsp;&nbsp;RETURN $9a<br>
        ELSEIF aUnicodeChar&amp;=&amp;0178 // &quot;&Yuml;&quot; latin capital letter y with diaeresis<br>
        &nbsp;&nbsp;RETURN $9f<br>
        ELSEIF aUnicodeChar&amp;=&amp;017b // &quot;&#381;&quot; latin capital letter z with caron<br>
        &nbsp;&nbsp;RETURN $8e<br>
        ELSEIF aUnicodeChar&amp;=&amp;017e // &quot;&#382;&quot; latin small letter z with caron<br>
        &nbsp;&nbsp;RETURN $9e<br>
        ELSEIF aUnicodeChar&amp;=&amp;0192 // &quot;&fnof;&quot; function f<br>
        &nbsp;&nbsp;RETURN $83<br>
        ELSEIF aUnicodeChar&amp;=&amp;02c6 // &quot;&circ;&quot; modifier letter circumflex accent<br>
        &nbsp;&nbsp;RETURN $88<br>
        ELSEIF aUnicodeChar&amp;=&amp;02dc // &quot;&tilde;&quot; small tilde<br>
        &nbsp;&nbsp;RETURN $98<br>
        ELSEIF aUnicodeChar&amp;=&amp;2013 // &quot;&ndash;&quot; en dash<br>
        &nbsp;&nbsp;RETURN $96<br>
        ELSEIF aUnicodeChar&amp;=&amp;2015 // &quot;&mdash;&quot; horizontal bar<br>
        &nbsp;&nbsp;RETURN $97<br>
        ELSEIF aUnicodeChar&amp;=&amp;2018 // &quot;&lsquo;&quot; left single quotation mark<br>
        &nbsp;&nbsp;RETURN $91<br>
        ELSEIF aUnicodeChar&amp;=&amp;2019 // &quot;&rsquo;&quot; right single quotation mark<br>
        &nbsp;&nbsp;RETURN $92<br>
        ELSEIF aUnicodeChar&amp;=&amp;201a // &quot;,&quot; single low quotation mark<br>
        &nbsp;&nbsp;RETURN $82<br>
        ELSEIF aUnicodeChar&amp;=&amp;201c // &quot;&ldquo;&quot; left double quotation mark<br>
        &nbsp;&nbsp;RETURN $93<br>
        ELSEIF aUnicodeChar&amp;=&amp;201d // &quot;&rdquo;&quot; right double quotation mark<br>
        &nbsp;&nbsp;RETURN $94<br>
        ELSEIF aUnicodeChar&amp;=&amp;201e // &quot;&bdquo;&quot; double comma<br>
        &nbsp;&nbsp;RETURN $84<br>
        ELSEIF aUnicodeChar&amp;=&amp;2020 // &quot;&dagger;&quot; dagger, long cross<br>
        &nbsp;&nbsp;RETURN $86<br>
        ELSEIF aUnicodeChar&amp;=&amp;2021 // &quot;&Dagger;&quot; double dagger<br>
        &nbsp;&nbsp;RETURN $87<br>
        ELSEIF aUnicodeChar&amp;=&amp;2022 // &quot;&bull;&quot; bullet<br>
        &nbsp;&nbsp;RETURN $95<br>
        ELSEIF aUnicodeChar&amp;=&amp;2026 // &quot;&hellip;&quot; horizontal ellipsis<br>
        &nbsp;&nbsp;RETURN $85<br>
        ELSEIF aUnicodeChar&amp;=&amp;2030 // &quot;&permil;&quot; permille<br>
        &nbsp;&nbsp;RETURN $89<br>
        ELSEIF aUnicodeChar&amp;=&amp;2039 // &quot;&lsaquo;&quot; single left-pointing angle quotation mark<br>
        &nbsp;&nbsp;RETURN $8b <br>
        ELSEIF aUnicodeChar&amp;=&amp;203a // &quot;&rsaquo;&quot; single right-pointing angle quotation mark<br>
        &nbsp;&nbsp;RETURN $9b<br>
        ELSEIF aUnicodeChar&amp;=&amp;20ac // &quot;&euro;&quot; euro<br>
        &nbsp;&nbsp;RETURN $80<br>
        ELSEIF aUnicodeChar&amp;=&amp;2122 // &quot;&trade;&quot; trade mark sign<br>
        &nbsp;&nbsp;RETURN $99<br>
        ELSE<br>
        &nbsp;&nbsp;RETURN KCvAsciiCharNotAvailable%<br>
        ENDIF<br>
      ENDP<br>
      <br>
      PROC CvCp1252ToPsion:(apText&amp;,aTextSize&amp;)<br>
        // used to convert a standard plain text as from MS WordPad to a Psion<br>
        // formatted plain text buffer<br>
        LOCAL pCurrent&amp;,pEnd&amp;,Char8%,NextChar8%<br>
        // initialise start values<br>
        pCurrent&amp;=apText&amp;<br>
        pEnd&amp;=apText&amp;+aTextSize&amp;<br>
        // convert<br>
        WHILE pCurrent&amp;&lt;pEnd&amp;<br>
        &nbsp;&nbsp;Char8%=PEEKB(pCurrent&amp;)<br>
        &nbsp;&nbsp;IF Char8%&gt;=$20 AND Char8%&lt;=$7f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;GOTO LBL_Continue::<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;IF pCurrent&amp;&lt;(pEnd&amp;-&amp;1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;NextChar8%=PEEKB(pCurrent&amp;+&amp;1)<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;NextChar8%=KCarriageReturnER5%<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;IF (Char8%=KLineFeedER5%) AND (NextChar8%=KLineFeedER5%)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KParagraphEndER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+&amp;1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KParagraphEndER5%<br>
        &nbsp;&nbsp;ELSEIF (Char8%=KLineFeedER5%) AND (NextChar8%=KCarriageReturnER5%)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KParagraphEndER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+&amp;1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KParagraphEndER5%<br>
        &nbsp;&nbsp;ELSEIF (Char8%=KCarriageReturnER5%) AND (NextChar8%=KLineFeedER5%)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KParagraphEndER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+&amp;1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KParagraphEndER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KCarriageReturnER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KLineBreakER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KLineFeedER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KParagraphEndER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KFormFeed%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KPageBreakER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KPotentialHyphen&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KPotentialHyphenER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KNonBreakingSpace&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KNonBreakingSpaceER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KVisibleSpaceCharacter&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,$20 rem KVisibleSpaceCharacterER5%<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// do nothing<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;LBL_Continue::<br>
        &nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+&amp;1<br>
        ENDWH<br>
      ENDP<br>
      <br>
      PROC CvPsionToCp1252:(apText&amp;,aTextSize&amp;)<br>
        // used to convert a Psion formatted plain text buffer to standard plain text<br>
        // which can be stored in a file and opened with MS WordPad or similar<br>
        LOCAL pCurrent&amp;,pEnd&amp;,Char8%,NextChar8%<br>
        // convert<br>
        pCurrent&amp;=apText&amp;<br>
        pEnd&amp;=apText&amp;+aTextSize&amp;<br>
        NextChar8%=KCarriageReturnER5%<br>
        WHILE pCurrent&amp;&lt;pEnd&amp;<br>
        &nbsp;&nbsp;Char8%=PEEKB(pCurrent&amp;)<br>
        &nbsp;&nbsp;IF Char8%&gt;=$20 AND Char8%&lt;=$7f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;GOTO LBL_Continue::<br>
        &nbsp;&nbsp;ENDIF <br>
        &nbsp;&nbsp;IF pCurrent&amp;&lt;(pEnd&amp;-&amp;1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;NextChar8%=PEEKB(pCurrent&amp;+&amp;1)<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;NextChar8%=KCarriageReturnER5%<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;IF (Char8%=KParagraphEndER5%) AND (NextChar8%=KParagraphEndER5%)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KLineFeedER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+&amp;1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KCarriageReturnER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KParagraphEndER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KLineFeedER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KLineBreakER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KCarriageReturnER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KPageBreakER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KFormFeed%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KNonBreakingTabER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KTabCharacterER5%<br>
        &nbsp;&nbsp;ELSEIF Char8%=KNonBreakingHyphenER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,$2d // minus sign<br>
        &nbsp;&nbsp;ELSEIF Char8%=KPotentialHyphenER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KPotentialHyphen&amp;<br>
        &nbsp;&nbsp;ELSEIF Char8%=KNonBreakingSpaceER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KNonBreakingSpace&amp;<br>
        &nbsp;&nbsp;ELSEIF Char8%=KVisibleSpaceCharacterER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,KVisibleSpaceCharacter&amp;<br>
        &nbsp;&nbsp;ELSEIF Char8%=KPictureCharacterER5%<br>
        &nbsp;&nbsp;&nbsp;&nbsp;POKEB pCurrent&amp;,$87 // double cross &Dagger;<br>
        &nbsp;&nbsp;ELSE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// do nothing<br>
        &nbsp;&nbsp;ENDIF<br>
        &nbsp;&nbsp;LBL_Continue::<br>
        &nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+&amp;1<br>
        ENDWH<br>
        ENDP</font></td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0022" id="dpNote0022"></a></b></font></b><font color="#000080">dpNote 
        0022</font></b></font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">8 April 2006</font></font><br>
        <font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080"><br>
        All OPL versions</font></font></td>
    <td><p><font size="-1"><b><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"><b><b><font color="#000080">Converting between Unicode and  SCSU<br>
      </font></b></b></font></font></b><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"><font color="#000080"><br>
        You often read in  Symbian documentation that from ER6 onwards (<font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"><font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1">strictly speaking from ER5.1 or ER5u</font></font></font></font></font></font></font> <font color="#000080">onwards) text is stored in Unicode format. More precisely, you often see references to UTF-16, which is a Unicode representation where every code point is 2 byte, <font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"><font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1">i.e. characters are represented by two bytes instead of one byte enabling native representation of non-ASCII languages such as Greek, Russian, Thai, Chinese and Arabic</font></font></font></font></font></font> as well as a number of special characters. <br>
        <br>
        But then when you wish to do some programming you realise that this is actually not the case!<br>
        <br>
        From the outset, I suspected something to be amiss when some programmers reported that text copied into the Clipboard file on an ER6 or ER7 device appears to be in single byte ASCII format. But this could not be the case, since it is not possible to represent Unicode characters with ASCII.<br>
        <br>
        A simple test can be done by opening Symbian Word in a Nokia 9210 or 9500 and copy a 2 byte Unicode character (i.e. <font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1">&quot;&euro;&quot; which in Unicode is represented by the 0x20AC code point) </font></font></font>and then pasting it into another document. It is obvious that the clipboard can handle two byte characters. Hence the claim that the clipboard file stores text in ASCII format must simply be wrong, or at least not the whole story.<br>
        <br>
        The following characters are included in Code Page 1252 on an ER5 device but have two byte representation in Unicode: <br>
        <br>
        - The ellipsis &quot;&hellip;&quot; is stored as 0x85 in Code Page 1252, but as 0x2026 in Unicode.<br>
        - The Euro sign &quot;&euro;&quot; is stored as 0x80 in Code Page 1252, but as 0x20AC in Unicode.<br>
        - The trademark sign &quot;&trade;&quot; is stored as 0x99 in Code Page 1252, but as 0x2122 in Unicode. <br>
        <br>
        Assume we copy the string &quot;aaaa<font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1">&euro;aaaa&quot; into a Sony Ericsson P900 clipboard. Then let's examine the clipboard file using a hex editor. If the string had been stored as pure UTF-16LE Unicode (i.e. 16 bit little endian representation) we would have expected:<br>
        <br>
      </font></font></font>0x61 00 61 00 61 00 61 00 AC 20 61 00 61 00 61 00 61 00.<br>
      <br>
        If it had been stored as UTF-16BE (big endian) we would have expected:<br>
        <br>
        </font></font></font></font><font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"> <font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"><font color="#000080">0x00 61 00 61 00 61 00 61 20 AC 00 61 00 61 00 61 00 61.<br>
        </font></font></font></font><font color="#000080"><br>
        But instead we get:<br>
        <br>
        0x61 61 61 61 06 2C 61 61 61 61.<br>
        <br>
        And for the string &quot;<font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"><font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1">&euro;</font>&euro;&euro;&euro;&euro;&euro;&euro;&euro;&euro;</font></font></font></font></font></font>&quot;<br>
        <br>
        we get:<br>
        <br> 
        <font color="#000080">0x1C 41 AC AC AC AC AC AC AC AC AC<br> 
        <br>
        It appears that in isolation Euro sign is represented by 2 bytes, but the a:s are represented by 1 byte, thus saving space.<br>
        <br>
        For a UFT-16 representation, we had expected Length&amp;=9 and Size&amp;=18. The size of a UTF-16 string should always be twice the length. Hence, for instance the new OPL keyword <font color="#000000" face="Courier New, Courier, monospace">SIZE(aString$)</font> will give twice the value of <font color="#000000" face="Courier New, Courier, monospace">LEN(aString$)</font>. But in the second case, Length&amp;=9 and Size&amp;=10. In other words it's a quite significant memory saving.<br>
        <br>
        <font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1">When the Euro sign was repeated, there is another representation of the Euro sign allowing a Unicode character string of Length&amp;=9 to be represented by a buffer of Size&amp;=11.</font></font></font><br>
        <br>
        Doing some further tests, it appears that ASCII characters, i.e. characters between 0x20 (space) and 0x7F (delete) are stored without modification as single byte characters (hence giving rise to the widely spread but erroneous assumption that Symbian clipboard file stores text in ASCII format). But strange things happen to all other characters. <br>
        <br>
        The answer is the following: <strong>most native Symbian text stores makes use of something called Standard Compression Scheme for Unicode (SCSU)</strong>. The SCSU is described in the <a href="http://web.archive.org/web/20080323085741/http://www.unicode.org/reports/tr6/">Unicode technical standard #6.</a> In fact, contrary to popular belief, Symbian does not store text in UTF-16 format, but in the SCSU format. <br>
        <br>
        This means that if we are to faithfully handle text in OPL we will need an SCSU converter. Else, for instance, a clipboard handler in ER6 or ER7 will not work properly for non-ASCII characters. Studying Convert.opx in ER6 doesn't help, since it doesn't offer an SCSU converter.<br>
        <br>
        One additional complication is that whereas Length&amp; obviously doesn't change, the Size&amp; of any text segment is entirely depending on what characters there are in the segment. If we look at the example above, if the string had been &quot;aaaaaaaaa&quot;, the Length&amp; and Size&amp; after SCSU conversion should both be 9. When one double byte character was introduced, the Size&amp;, predictably, increased by one. But when all a:s were replaced by double byte characters, the Size&amp; only increased to 11, not to 18 as might have been predicted. In all cases the Length&amp;, i.e. the actual number of characers in the string, remained the same. <br>
        <br>
        After much studying of the SCSU standard and how to encode and decode SCSU, I came up with the following quite fast routines for handling SCSU in OPL. The two main procedures here are </font><font size="-1" face="Courier New, Courier, monospace">CvUnicodeToScsu:</font> and </font><font size="-1" face="Courier New, Courier, monospace">CvScsuToUnicode:</font><font size="-1"><font color="#000080">. Take note that Length&amp; always has to be passed. Otherwise it is not known, since, as per the above, it cannot be calculated from Size&amp; nor vice verse.<br>
        <font color="#000000" face="Courier New, Courier, monospace"><br>
        // SCSU constants<br>
        CONST KScsu_SQ0%=$01    // Quote Static Window 0 (non-Locking)<br>
        CONST KScsu_SQ1%=$02    // Quote Static Window 1 (non-Locking)<br>
        CONST KScsu_SQ2%=$03    // Quote Static Window 2 (non-Locking)<br>
        CONST KScsu_SQ3%=$04    // Quote Static Window 3 (non-Locking)<br>
        CONST KScsu_SQ4%=$05    // Quote Static Window 4 (non-Locking)<br>
        CONST KScsu_SQ5%=$06    // Quote Static Window 5 (non-Locking)<br>
        CONST KScsu_SQ6%=$07    // Quote Static Window 6 (non-Locking)<br>
        CONST KScsu_SQ7%=$08    // Quote Static Window 7 (non-Locking)<br>
        CONST KScsu_SDX%=$0b    // Define Extended Window<br>
        CONST KScsu_SR%=$0c     // Reserved for future use<br>
        CONST KScsu_SQU%=$0e    // Quote Unicode (non-Locking)<br>
        CONST KScsu_SCU%=$0f    // Change to Unicode (Locking)<br>
        CONST KScsu_SC0%=$10    // Shift to Dynamic Window 0 (Locking)<br>
        CONST KScsu_SC1%=$11    // Shift to Dynamic Window 1 (Locking)<br>
        CONST KScsu_SC2%=$12    // Shift to Dynamic Window 2 (Locking)<br>
        CONST KScsu_SC3%=$13    // Shift to Dynamic Window 3 (Locking)<br>
        CONST KScsu_SC4%=$14    // Shift to Dynamic Window 4 (Locking)<br>
        CONST KScsu_SC5%=$15    // Shift to Dynamic Window 5 (Locking)<br>
        CONST KScsu_SC6%=$16    // Shift to Dynamic Window 6 (Locking)<br>
        CONST KScsu_SC7%=$17    // Shift to Dynamic Window 7 (Locking)<br>
        CONST KScsu_SD0%=$18    // Define Dynamic Window 0 (Locking)<br>
        CONST KScsu_SD1%=$19    // Define Dynamic Window 1 (Locking)<br>
        CONST KScsu_SD2%=$1a    // Define Dynamic Window 2 (Locking)<br>
        CONST KScsu_SD3%=$1b    // Define Dynamic Window 3 (Locking)<br>
        CONST KScsu_SD4%=$1c    // Define Dynamic Window 4 (Locking)<br>
        CONST KScsu_SD5%=$1d    // Define Dynamic Window 5 (Locking)<br>
        CONST KScsu_SD6%=$1e    // Define Dynamic Window 6 (Locking)<br>
        CONST KScsu_SD7%=$1f    // Define Dynamic Window 7 (Locking)<br>
        CONST KScsu_UC0&amp;=&amp;e000  // Shift to Dynamic Window 0 (Locking)<br>
        CONST KScsu_UC1&amp;=&amp;e100  // Shift to Dynamic Window 1 (Locking)<br>
        CONST KScsu_UC2&amp;=&amp;e200  // Shift to Dynamic Window 2 (Locking)<br>
        CONST KScsu_UC3&amp;=&amp;e300  // Shift to Dynamic Window 3 (Locking)<br>
        CONST KScsu_UC4&amp;=&amp;e400  // Shift to Dynamic Window 4 (Locking)<br>
        CONST KScsu_UC5&amp;=&amp;e500  // Shift to Dynamic Window 5 (Locking)<br>
        CONST KScsu_UC6&amp;=&amp;e600  // Shift to Dynamic Window 6 (Locking)<br>
        CONST KScsu_UC7&amp;=&amp;e700  // Shift to Dynamic Window 7 (Locking)<br>
        CONST KScsu_UD0&amp;=&amp;e800  // Define &amp; Change to Dynamic Window 0 (Locking)<br>
        CONST KScsu_UD1&amp;=&amp;e900  // Define &amp; Change to Dynamic Window 1 (Locking)<br>
        CONST KScsu_UD2&amp;=&amp;ea00  // Define &amp; Change to Dynamic Window 2 (Locking)<br>
        CONST KScsu_UD3&amp;=&amp;eb00  // Define &amp; Change to Dynamic Window 3 (Locking)<br>
        CONST KScsu_UD4&amp;=&amp;ec00  // Define &amp; Change to Dynamic Window 4 (Locking)<br>
        CONST KScsu_UD5&amp;=&amp;ed00  // Define &amp; Change to Dynamic Window 5 (Locking)<br>
        CONST KScsu_UD6&amp;=&amp;ee00  // Define &amp; Change to Dynamic Window 6 (Locking)<br>
        CONST KScsu_UD7&amp;=&amp;ef00  // Define &amp; Change to Dynamic Window 7 (Locking)<br>
        CONST KScsu_UQU&amp;=&amp;f000  // Quote Unicode character (non-locking)<br>
        CONST KScsu_UDX&amp;=&amp;f100  // Define extended window<br>
        CONST KScsu_UR&amp;=&amp;f200    // Reserved for future use<br>
        // static window offsets<br>
        CONST KScsuStaticWindow0&amp;=&amp;0000      // For quoting of tags used in single-byte mode<br>
        CONST KScsuStaticWindow1&amp;=&amp;0080      // Latin-1 Supplement<br>
        CONST KScsuStaticWindow2&amp;=&amp;0200      // Latin Extended-A<br>
        CONST KScsuStaticWindow3&amp;=&amp;0300      // Combining Diacritical Marks<br>
        CONST KScsuStaticWindow4&amp;=&amp;2000      // General Punctuation<br>
        CONST KScsuStaticWindow5&amp;=&amp;2080      // Currency Symbols<br>
        CONST KScsuStaticWindow6&amp;=&amp;2100      // Letterlike Symbols and Number Forms<br>
        CONST KScsuStaticWindow7&amp;=&amp;3000      // CJK Symbols and Punctuation<br>
        // dynamic window default offsets<br>
        CONST KScsuDynamicWindow0&amp;=&amp;0080     // Latin-1 Supplement<br>
        CONST KScsuDynamicWindow1&amp;=&amp;00c0     // Combined partial Latin-1 Supplement/LatinExtended-A<br>
        CONST KScsuDynamicWindow2&amp;=&amp;0400     // Cyrillic<br>
        CONST KScsuDynamicWindow3&amp;=&amp;0600     // Arabic<br>
        CONST KScsuDynamicWindow4&amp;=&amp;0900     // Devanagari<br>
        CONST KScsuDynamicWindow5&amp;=&amp;3040     // Hiragana<br>
        CONST KScsuDynamicWindow6&amp;=&amp;30a0     // Katakana<br>
        CONST KScsuDynamicWindow7&amp;=&amp;ff00     // Fullwidth Ascii<br>
        // dynamic window alternative offsets    Set by SDn<br>
        CONST KScsuDynamicWindowLatin1x&amp;=&amp;00c0       // $f9<br>
        CONST KScsuDynamicWindowIpaExt&amp;=&amp;0250        // $fa<br>
        CONST KScsuDynamicWindowGreek&amp;=&amp;0370         // $fb<br>
        CONST KScsuDynamicWindowArmenian&amp;=&amp;0530      // $fc<br>
        CONST KScsuDynamicWindowHiragana&amp;=&amp;3040      // $fd<br>
        CONST KScsuDynamicWindowKatakana&amp;=&amp;30a0      // $fe<br>
        CONST KScsuDynamicWindowHalfKatakana&amp;=&amp;ff60  // $ff<br>
        CONST KScsuDynamicWindowLowOffset&amp;=&amp;0000     // used for $00..$67 (&lt;  &amp;3400)<br>
        CONST KScsuDynamicWindowHighOffset&amp;=&amp;ac00    // used for $68..$A7 (&gt;= &amp;e000)<br>
        <br>
        </font></font></font></font></font><font size="-1" face="Courier New, Courier, monospace">PROC CvUnicodeToScsu:(_pText&amp;,aTextLen&amp;,_OutSize&amp;)<br>
        // encodes SCSU from Unicode<br>
        // Usage: CvUnicodeToScsu:(ADDR(pText&amp;),TextLen&amp;,ADDR(TextSize&amp;))
        <br>
        LOCAL pInStart&amp;,pIn&amp;,pInEnd&amp;,pOutStart&amp;,pOut&amp;,pOutEnd&amp;,OutSize&amp;<br>
        LOCAL Char8%,Char16&amp;,NextChar16&amp;,WindowLower&amp;,NextNextChar16&amp;<br>
        LOCAL StaticWindowOffset&amp;(8),DynamicWindowOffset&amp;(8),Youth&amp;(8)<br>
        LOCAL SingleQuoteWindowN%,DynamicWindowN%,UnicodeModeB%<br>
        LOCAL WindowFittedN%,IndexByte%<br>
        // Initialise default states<br>
        UnicodeModeB%=KFalse%<br>
        DynamicWindowN%=0<br>
        SingleQuoteWindowN%=0<br>
        // set the initially oldest window to Devanagari<br>
        Youth&amp;(0+1)=3 // Latin-1 Supplement<br>
        Youth&amp;(1+1)=2 // Combined partial Latin-1 Supplement/Latin Extended-A<br>
        Youth&amp;(2+1)=1 // Cyrillic<br>
        Youth&amp;(3+1)=1 // Arabic<br>
        Youth&amp;(4+1)=0 // Devanagari<br>
        Youth&amp;(5+1)=1 // Hiragana<br>
        Youth&amp;(6+1)=1 // Katakana<br>
        Youth&amp;(7+1)=2 // Fullwidth Ascii<br>
        // Initialise static window offsets (will never be changed)<br>
        CvScsuStaticWindowInitialise:(ADDR(StaticWindowOffset&amp;()))<br>
        // Initialise default dynamic window offsets<br>
        CvScsuDynamicWindowInitialise:(ADDR(DynamicWindowOffset&amp;()))<br>
        // in this operation the OutSize&amp; will normally be smaller than 2*TextLen&amp;<br>
        // but it's not absolutely certain.<br>
        OutSize&amp;=aTextLen&amp;*KUnicodeFactor%<br>
        pOut&amp;=ALLOC(OutSize&amp;*3/2)  // give a little more just in case<br>
        IF pOut&amp;=0 :RAISE KErrNoMemory% :ENDIF<br>
        // set up the pointers we need<br>
        // pInStart&amp;      points to the start of the text before encoding<br>
        // pIn&amp;           points to the current position in the text read from<br>
        // pInEnd&amp;        points to the first byte after the text before encoding<br>
        // pOutStart&amp;     points to the start of the encoded text<br>
        // pOut&amp;          points to the current position in the text to write to<br>
        pInStart&amp;=PEEKL(_pText&amp;)<br>
        pIn&amp;=pInStart&amp;<br>
        pInEnd&amp;=pInStart&amp;+aTextLen&amp;*KUnicodeFactor%<br>
        pOutStart&amp;=pOut&amp;<br>
        // go char for char<br>
        WHILE pIn&amp;&lt;pInEnd&amp;<br>
&nbsp;&nbsp;// read Unicode little endian<br>
&nbsp;&nbsp;Char16&amp;=PeekWordLE&amp;:(pIn&amp;) :pIn&amp;=pIn&amp;+&amp;2<br>
&nbsp;&nbsp;IF pIn&amp;&lt;(pInEnd&amp;-&amp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;NextChar16&amp;=PeekWordLE&amp;:(pIn&amp;)<br>
&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;NextChar16&amp;=&amp;0000<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;IF UnicodeModeB%<br>
&nbsp;&nbsp;&nbsp;&nbsp;GOTO LBL_UnicodeMode::<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// <br>
&nbsp;&nbsp;// single mode<br>
&nbsp;&nbsp;//<br>
&nbsp;&nbsp;// if Char is part of static window 0 output StaticByte<br>
&nbsp;&nbsp;IF (Char16&amp;&gt;=&amp;0020 AND Char16&amp;&lt;=&amp;007f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Ascii codes<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store directly in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 1 outbyte<br>
&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;-&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// if Char is any of the common Ascii control characters output StaticByte<br>
&nbsp;&nbsp;IF Char16&amp;=&amp;0000 OR Char16&amp;=&amp;0009 OR Char16&amp;=&amp;000a OR Char16&amp;=&amp;000d<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Ascii ctrl codes<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store directly in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 1 outbyte<br>
&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;-&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// if Char is another Ascii control character output SQ0 then StaticByte<br>
&nbsp;&nbsp;// this is when Char conflicts with SCSU commands<br>
&nbsp;&nbsp;IF Char16&amp;&lt;=&amp;001f<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,KScsu_SQ0% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// if Char is compressible<br>
&nbsp;&nbsp;IF CvScsuCompressibleB%:(Char16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// if Char fits into the active dynamic window, output DynamicByte<br>
&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=DynamicWindowOffset&amp;(DynamicWindowN%+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF (Char16&amp;&gt;=WindowLower&amp;) AND (Char16&amp;&lt;(WindowLower&amp;+&amp;80))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=Youth&amp;(DynamicWindowN%+1)+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;-WindowLower&amp;+&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 1 outbyte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;-&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;// if Char fits into any currently defined dynamic window check the next<br>
&nbsp;&nbsp;&nbsp;&nbsp;// character NextChar<br>
&nbsp;&nbsp;&nbsp;&nbsp;WindowFittedN%=CvScsuWindowFitN%:(ADDR(DynamicWindowOffset&amp;()),Char16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF WindowFittedN%&lt;&gt;$ff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if NextChar fits the active dynamic window, output SQn tag for the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// window that Char fits into followed by DynamicByte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF NOT CvScsuCompressibleB%:(NextChar16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GOTO LBL_NoNextChar::<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (NextChar16&amp;&gt;=WindowLower&amp;) AND (NextChar16&amp;&lt;(WindowLower&amp;+&amp;80))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=DynamicWindowOffset&amp;(WindowFittedN%+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_SQ0%+WindowFittedN%): pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(Char16&amp;-WindowLower&amp;+&amp;80) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// change window with SCn, update window offset lower and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// change the dynamic window accordingly, then output DynamicByte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LBL_NoNextChar::<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=WindowFittedN%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=DynamicWindowOffset&amp;(WindowFittedN%+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=Youth&amp;(DynamicWindowN%+1)+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_SC0%+WindowFittedN%): pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(Char16&amp;-WindowLower&amp;+&amp;80) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;// if Char is in the BMP (basic multilingual plane)<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF CvScsuBasicMultilingualPlaneB%:(Char16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if Char fits into a static window, output SQn for that window followed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by StaticByte, however if NextChar fits into same static window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create a dynamic window based on this static window and change to this<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dynamic window - this has been added for the purpose of handling several<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// consecutive page &amp; line breaks $2028, $2029<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowFittedN%=CvScsuWindowFitN%:(ADDR(StaticWindowOffset&amp;()),Char16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF WindowFittedN%&lt;&gt;$ff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// check if NextChar is in the same window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (Char16&amp; AND &amp;0000ff80)=(NextChar16&amp; AND &amp;0000ff80)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// check if NextNextChar18&amp; is in the same window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (pIn&amp;+&amp;2)&lt;(pInEnd&amp;-&amp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NextNextChar16&amp;=PeekWordLE&amp;:(pIn&amp;+&amp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NextNextChar16&amp;=&amp;0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (NextNextChar16&amp; AND &amp;0000ff80)=(NextChar16&amp; AND &amp;0000ff80)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// select the oldest dynamic window as new window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=CvScsuWindowOldestN%:(ADDR(Youth&amp;()))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=StaticWindowOffset&amp;(WindowFittedN%+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=DynamicWindowOffset&amp;(DynamicWindowN%+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calculate the index<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF Char16&amp;&lt;&amp;3400<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=Char16&amp;/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE rem Char16&amp;&gt;=&amp;e000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=(Char16&amp;-&amp;ac00)/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;-WindowLower&amp;+&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// set this dynamic window as the active window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_SD0%+DynamicWindowN%) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,IndexByte% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 3 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GOTO LBL_NoSDRequired::<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LBL_NoSDRequired::<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_SQ0%+WindowFittedN%) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(Char16&amp;-StaticWindowOffset&amp;(WindowFittedN%+1)) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// otherwise output an SDn tag for a new dynamic window in the BMP<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// followed by DynamicByte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF Char16&amp;&lt;&amp;3400<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=Char16&amp;/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=IndexByte%*&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE rem Char16&amp;&gt;=&amp;e000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=(Char16&amp;-&amp;ac00)/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=IndexByte%*&amp;80+&amp;ac00<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;-WindowLower&amp;+&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// select the oldest dynamic window as new window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=CvScsuWindowOldestN%:(ADDR(Youth&amp;()))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// define the selected window as a new active window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=WindowLower&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_SD0%+DynamicWindowN%) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,IndexByte% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 3 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;// otherwise, if Char is not in BMP, output an SDX for a new dynamic<br>
&nbsp;&nbsp;&nbsp;&nbsp;// window in the supplimentary code space<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF Char16&amp;&gt;&amp;0010ffff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RAISE KErrOverflow%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calculate window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=(Char16&amp;-&amp;00010000)/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=IndexByte%*&amp;80+&amp;00010000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;-WindowLower&amp;+&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// select the oldest dynamic window as new window. since <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=CvScsuWindowOldestN%:(ADDR(Youth&amp;()))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// define the window selected<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=WindowLower&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// format is 'nnnb bbbb bbbb bbbb' in bits<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=DynamicWindowN%*&amp;2000+IndexByte%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pokes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,KScsu_SDX% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordBE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 4 outbyte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// these are cases when Char is not compressible<br>
&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;// if Char is in BMP and NextChar is compressible, output an SQU tag<br>
&nbsp;&nbsp;&nbsp;&nbsp;// followed by Char16 <br>
&nbsp;&nbsp;&nbsp;&nbsp;IF CvScsuBasicMultilingualPlaneB%:(Char16&amp;) AND CvScsuCompressibleB%:(NextChar16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,KScsu_SQU% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordBE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 3 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// otherwise output an SCU tag (switching to Unicode) followed by Char16<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KTrue%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,KScsu_SCU% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordBE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 3 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;//<br>
&nbsp;&nbsp;// Unicode mode<br>
&nbsp;&nbsp;// <br>
&nbsp;&nbsp;LBL_UnicodeMode::<br>
&nbsp;&nbsp;// if Char is compressible and NextChar is also compressible<br>
&nbsp;&nbsp;IF CvScsuCompressibleB%:(Char16&amp;) AND CvScsuCompressibleB%:(NextChar16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// handle the case when Char is in Ascii range<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF (Char16&amp;&gt;=&amp;0020) AND (Char16&amp;&lt;=&amp;007f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_UC0&amp;/&amp;0100+DynamicWindowN%) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// leave Unicode mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF Char16&amp;=&amp;0000 OR Char16&amp;=&amp;000a OR Char16&amp;=&amp;000d OR Char16&amp;=&amp;0009<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_UC0&amp;/&amp;0100+DynamicWindowN%) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// leave Unicode mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF Char16&amp;&lt;&amp;0020<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// these are possible conflict characters, let's use UQU<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,KScsu_UQU&amp;/&amp;0100 :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,$00 :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 3 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;// if Char fits in any currenty defined dynamic window, output UCn tag for<br>
&nbsp;&nbsp;&nbsp;&nbsp;// that window followed by DynamicByte<br>
&nbsp;&nbsp;&nbsp;&nbsp;WindowFittedN%=CvScsuWindowFitN%:(ADDR(DynamicWindowOffset&amp;()),Char16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF WindowFittedN%&lt;&gt;$ff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=WindowFittedN%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=DynamicWindowOffset&amp;(DynamicWindowN%+1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=Youth&amp;(DynamicWindowN%+1)+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_UC0&amp;/&amp;0100+DynamicWindowN%) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(Char16&amp;-WindowLower&amp;+&amp;80) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// leave Unicode mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;// otherwise, if Char is in the BMP, output UDn tag (with parameter) for<br>
&nbsp;&nbsp;&nbsp;&nbsp;// a new dynamic window in the BMP followed by DynamicBute<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF CvScsuBasicMultilingualPlaneB%:(Char16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF Char16&amp;&lt;&amp;3400<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=Char16&amp;/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=IndexByte%*&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE rem Char16&amp;&gt;=&amp;e000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=(Char16&amp;-&amp;ac00)/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=IndexByte%*&amp;80+&amp;ac00<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// select the oldest dynamic window for redefinition<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=CvScsuWindowOldestN%:(ADDR(Youth&amp;()))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=WindowLower&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(KScsu_UD0&amp;/&amp;0100+DynamicWindowN%) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,IndexByte% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,(Char16&amp;-WindowLower&amp;+&amp;80) :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// leave Unicode mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 3 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;// otherwise, output a UDX tag (with parameter) for a new dynamic window<br>
&nbsp;&nbsp;&nbsp;&nbsp;// in supplementary code space followed by DynamicByte<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF Char16&amp;&gt;&amp;0010ffff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RAISE KErrOverflow%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calculate window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexByte%=(Char16&amp;-&amp;00010000)/&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowLower&amp;=IndexByte%*&amp;80+&amp;00010000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char8%=Char16&amp;-WindowLower&amp;+&amp;80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// select the oldest dynamic window for redefinition<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=CvScsuWindowOldestN%:(ADDR(Youth&amp;()))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Youth&amp;(DynamicWindowN%+1)=2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=WindowLower&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// format is 'nnnb bbbb bbbb bbbb' in bits<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=DynamicWindowN%*&amp;2000+IndexByte%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pokes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,KScsu_UDX&amp;/&amp;0100 :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// leave Unicode mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 4 outbyte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// Char and NextChar are not both compressibles<br>
&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;// if the most signficant 8 bits of Char conflict with a tag or reserved<br>
&nbsp;&nbsp;&nbsp;&nbsp;// value in Scsu Unicode mode, output a UQU tag<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF CvScsuUnicodeTagConflictB%:(Char16&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POKEB:(pOut&amp;,KScsu_UQU&amp;/&amp;0100) :pOut&amp;=pOut&amp;+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordBE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 3 outbyte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutSize&amp;=OutSize&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// else output Char in UTF-16BE and stay in Unicode mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PokeWordBE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes, 2 outbyte<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem OutSize&amp;=OutSize&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;ENDIF<br>
        ENDWH<br>
        // adjust size of outbuffer, since it may have been reduced<br>
        pOutStart&amp;=REALLOC(pOutStart&amp;,OutSize&amp;)<br>
        // the outbuffer has now replaced the inbuffer<br>
        FREEALLOC(pInStart&amp;)<br>
        // return BYREF values<br>
        POKEL _pText&amp;,pOutStart&amp;<br>
        POKEL _OutSize&amp;,OutSize&amp;<br>
        ENDP<br>
        <br>
      PROC CvScsuUnicodeTagConflictB%:(aChar16&amp;)<br>
      IF ((aChar16&amp; AND &amp;ff00)&gt;=(KScsu_UC0&amp; AND &amp;ff00))<br>
&nbsp;&nbsp;IF ((aChar16&amp; AND &amp;ff00)&lt;=(KScsu_UR&amp; AND &amp;ff00))<br>
&nbsp;&nbsp;&nbsp;&nbsp;RETURN KTrue%<br>
&nbsp;&nbsp;ENDIF<br>
        ENDIF<br>
        RETURN KFalse%<br>
        ENDP<br>
        <br>
      PROC CvScsuBasicMultilingualPlaneB%:(aChar&amp;)<br>
&nbsp;&nbsp;RETURN ((aChar&amp;&gt;=&amp;0000) AND (aChar&amp;&lt;=&amp;ffff))<br>
        ENDP<br>
        <br>
      PROC CvScsuWindowOldestN%:(_Youth&amp;)<br>
        // returns the oldest dynamic window<br>
        // Usage:<br>
        // OldestDynamicWindowN%=CvScsuWindowOldestN%:(ADDR(Youth&amp;()))<br>
        LOCAL OldestN%,n%,OldestAge&amp;,Youth&amp;<br>
        OldestN%=7<br>
        n%=OldestN%<br>
        OldestAge&amp;=KMaxLong&amp;<br>
        WHILE n%&gt;=0<br>
&nbsp;&nbsp;Youth&amp;=PEEKL(_Youth&amp;+n%*KLongSize&amp;)<br>
&nbsp;&nbsp;IF Youth&amp;&lt;OldestAge&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;OldestN%=n%<br>
&nbsp;&nbsp;&nbsp;&nbsp;OldestAge&amp;=Youth&amp;<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;n%=n%-1<br>
        ENDWH<br>
        RETURN OldestN%<br>
        ENDP<br>
        <br>
      PROC CvScsuWindowFitB%:(_WindowOffset&amp;,aChar16&amp;)<br>
      // checks if aChar16&amp; is in any of the currenly active windows<br>
      RETURN (CvScsuWindowFitN%:(_WindowOffset&amp;,aChar16&amp;)&lt;&gt;$ff)<br>
        ENDP<br>
        <br>
      PROC CvScsuWindowFitN%:(_WindowOffset&amp;,aChar16&amp;)<br>
      // returns the number of the active window which aChar16&amp; fits into and<br>
        // returns $ff if it doesn't fit into any active window<br>
        // usage:<br>
        // WindowN%=CvScsuWindowFitN%:(ADDR(ActiveWindowOffset&amp;()),Char16&amp;)<br>
        LOCAL i%,Lower&amp;,Upper&amp;<br>
        // returned value between $00..$07 or $ff for not found<br>
        i%=$00<br>
        WHILE i%&lt;=$07<br>
&nbsp;&nbsp;Lower&amp;=PEEKL(_WindowOffset&amp;+i%*KLongSize&amp;)
<br>
&nbsp;&nbsp;Upper&amp;=Lower&amp;+&amp;80<br>
&nbsp;&nbsp;IF aChar16&amp;&gt;=Lower&amp; AND aChar16&amp;&lt;Upper&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;RETURN i%<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;i%=i%+1<br>
        ENDWH<br>
        RETURN $ff<br>
        ENDP<br>
        <br>
      PROC CvScsuCompressibleB%:(aChar16&amp;)<br>
      RETURN ((aChar16&amp;&lt;&amp;3400) OR (aChar16&amp;&gt;=&amp;e000))<br>
        ENDP<br>
        <br>
      PROC CvScsuToUnicode:(_pText&amp;,aTextLen&amp;,_TextSize&amp;)<br>
        // decodes SCSU (Standard Compression Scheme for Unicode) format to Unicode<br>
        //<br>
        // Usage: CvScsuToUnicode:(ADDR(pText&amp;),TextLen&amp;,ADDR(TextSize&amp;))<br>
        // pText&amp;     pointer to text buffer<br>
        // TextLen&amp;   length of text in actual characters, e.g. XList<br>
        // TextSize&amp;  size of text, can be undefined when passed, but will be set<br>
        //<br>
        LOCAL pInStart&amp;,pIn&amp;,pOutStart&amp;,pOut&amp;,TextSize&amp;<br>
        LOCAL Char8%,Char16&amp;<br>
        LOCAL StaticWindowOffset&amp;(8),DynamicWindowOffset&amp;(8)<br>
        LOCAL SingleQuoteWindowN%,DynamicWindowN%,UnicodeModeB%<br>
        // Initialise default states<br>
        UnicodeModeB%=KFalse%<br>
        DynamicWindowN%=0<br>
        SingleQuoteWindowN%=0<br>
        // Initialise static window offsets (will never be changed)<br>
        CvScsuStaticWindowInitialise:(ADDR(StaticWindowOffset&amp;()))<br>
        // Initialise default dynamic window offsets<br>
        CvScsuDynamicWindowInitialise:(ADDR(DynamicWindowOffset&amp;()))<br>
        // this the actual XList length which should be multiplied by 2 to get the<br>
        // final outsize for UTF-16 characters. #### HOWEVER #### if we later support<br>
        // Extended Plane Unicode, the OutSize needs to be adjusted everytime we<br>
        // encounter such character<br>
        TextSize&amp;=aTextLen&amp;*KUnicodeFactor%<br>
        // allocate buffer with some extra space<br>
        pOut&amp;=ALLOC(TextSize&amp;*2)<br>
        IF pOut&amp;=0 :RAISE KErrNoMemory% :ENDIF<br>
        // set up the pointers we need<br>
        // pInStart&amp;      points to the start of the text before conversion<br>
        // pIn&amp;           points to the current position in the text read from<br>
        // pOutStart&amp;     points to the start of the converted text<br>
        // pOut&amp;          points to the current position in the text to write to<br>
        pInStart&amp;=PEEKL(_pText&amp;)<br>
        pIn&amp;=pInStart&amp;<br>
        pOutStart&amp;=pOut&amp;<br>
        // go byte by byte<br>
        WHILE (pOut&amp;-pOutStart&amp;)&lt;TextSize&amp;<br>
&nbsp;&nbsp;IF UnicodeModeB%<br>
&nbsp;&nbsp;&nbsp;&nbsp;GOTO LBL_UnicodeMode::<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// <br>
&nbsp;&nbsp;// single mode<br>
&nbsp;&nbsp;// <br>
&nbsp;&nbsp;Char8%=PEEKB(pIn&amp;) :pIn&amp;=pIn&amp;+&amp;1<br>
&nbsp;&nbsp;IF Char8%&gt;=$20 AND Char8%&lt;=$7f<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Ascii codes, belong to Static Window 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store directly in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,$00 :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbyte, 2 outbytes<br>
&nbsp;&nbsp;ELSEIF Char8%&gt;=$80<br>
&nbsp;&nbsp;&nbsp;&nbsp;// use the current dynamic window<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=DynamicWindowOffset&amp;(DynamicWindowN%+1)+(Char8%-$80)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbyte, 2 outbytes<br>
&nbsp;&nbsp;ELSEIF Char8%=KKeyTab% OR Char8%=KCarriageReturnER5% OR Char8%=KLineFeedER5%<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store directly in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,Char8% :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;POKEB pOut&amp;,$00 :pOut&amp;=pOut&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbyte, 2 outbytes<br>
&nbsp;&nbsp;// SQU is used for isolated characters which do not fit into any of the current<br>
&nbsp;&nbsp;// windows <br>
&nbsp;&nbsp;ELSEIF Char8%=KScsu_SQU%                    // $0e - Single Quote Unicode<br>
&nbsp;&nbsp;&nbsp;&nbsp;// unicode character as *big* endian<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=PEEKB(pIn&amp;)*&amp;0100+PEEKB(pIn&amp;+1) :pIn&amp;=pIn&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 3 inbytes used, 2 outbytes<br>
&nbsp; // SQ0 does a single quote from window 0<br>
&nbsp;&nbsp;ELSEIF Char8%=KScsu_SQ0%                    // Window 0 non-Locking<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char8%=PEEKB(pIn&amp;) :pIn&amp;=pIn&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// should only be used for control characters which would otherwise collide<br>
&nbsp;&nbsp;&nbsp;&nbsp;// with tag bytes.<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF Char8%&lt;$20<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=Char8% // Since StaticWindowOffset&amp;(0+1)=&amp;00000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSEIF Char8%&gt;=$80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=DynamicWindowOffset&amp;(1)+(Char8%-$80)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// check for ER5 specific characters and convert to ascii<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// characters after SQ0 between $20 and $7f are actually illegal but <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// according to SCSU they should not be reported as errors<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no conversion needed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=Char8%<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp; // store in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes used, 2 outbytes<br>
&nbsp;&nbsp;// SQn does a single quote from window n<br>
&nbsp;&nbsp;ELSEIF Char8%&gt;=KScsu_SQ1% AND Char8%&lt;=KScsu_SQ7%  // SQ1-SQ7 non-Locking<br>
&nbsp;&nbsp;&nbsp;&nbsp;SingleQuoteWindowN%=Char8%-KScsu_SQ0%<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char8%=PEEKB(pIn&amp;) :pIn&amp;=pIn&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// choose between static and dynamic half-block<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF Char8%&lt;$80<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=StaticWindowOffset&amp;(SingleQuoteWindowN%+1)+Char8%<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=DynamicWindowOffset&amp;(SingleQuoteWindowN%+1)+(Char8%-$80)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes used, 2 outbytes<br>
&nbsp;&nbsp;// SCn changes to window N<br>
&nbsp;&nbsp;ELSEIF Char8%&gt;=KScsu_SC0% AND Char8%&lt;=KScsu_SC7%     // SCn<br>
&nbsp;&nbsp;&nbsp;&nbsp;// set window locking<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=Char8%-KScsu_SC0%<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbyte used, 0 outbyte<br>
&nbsp;&nbsp;// SDn defines a dynamic window N and changes to window N<br>
&nbsp;&nbsp;ELSEIF Char8%&gt;=KScsu_SD0% AND Char8%&lt;=KScsu_SD7%     // SDn<br>
&nbsp;&nbsp;&nbsp;&nbsp;// set window locking<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=Char8%-KScsu_SD0%<br>
&nbsp;&nbsp;&nbsp;&nbsp;// read in second byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char8%=PEEKB(pIn&amp;) :pIn&amp;=pIn&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// change offset of dynamic window according to second byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=CvScsuDynamicWindow&amp;:(Char8%)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes used, 0 outbytes<br>
&nbsp;&nbsp;// SCU changes to Unicode Mode<br>
&nbsp;&nbsp;ELSEIF Char8%=KScsu_SCU%<br>
&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KTrue% <br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbytes used, 0 outbytes<br>
&nbsp;&nbsp;// defines window in expansion space and sets to it<br>
&nbsp;&nbsp;ELSEIF Char8%=KScsu_SDX%<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=PeekWordBE&amp;:(pIn&amp;) :pIn&amp;=pIn&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// set window based on the top three bits<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=(Char16&amp; AND &amp;e000)/&amp;2000<br>
&nbsp;&nbsp;&nbsp;&nbsp;// calculate the new offset in expansion space based on remaining bits<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=&amp;10000+(&amp;80*(Char16&amp; AND &amp;1fff))<br>
&nbsp;&nbsp;&nbsp;&nbsp;// the character will be interpreted in the next round so no<br>
&nbsp;&nbsp;&nbsp;&nbsp;// outbyte here<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 3 inbytes used, 0 outbytes<br>
&nbsp;&nbsp;ELSEIF Char8%=KScsu_SR%<br>
&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;S Reserved&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbyte used, 0 outbytes<br>
&nbsp;&nbsp;ELSE rem Char8%&lt;=$ff AND Char8%&gt;=$a0<br>
&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;bad S character: &quot;+HEX$(Char8%))<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbyte used, 0 outbytes<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;CONTINUE<br>
&nbsp;&nbsp;//<br>
&nbsp;&nbsp;// handle Unicode Mode<br>
&nbsp;&nbsp;//<br>
&nbsp;&nbsp;LBL_UnicodeMode::<br>
&nbsp;&nbsp;Char16&amp;=PeekWordBE&amp;:(pIn&amp;) :pIn&amp;=pIn&amp;+2<br>
&nbsp;&nbsp;IF Char16&amp;&lt;KScsu_UC0&amp; // &amp;e000<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes used, 2 outbyte<br>
&nbsp;&nbsp;ELSEIF  Char16&amp;&gt;=&amp;f300 AND Char16&amp;&lt;=&amp;ffff<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbytes used, 2 outbyte<br>
&nbsp;&nbsp;ELSEIF Char16&amp;&gt;=KScsu_UC0&amp; AND Char16&amp;&lt;=(KScsu_UC7&amp;+&amp;ff)<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=((Char16&amp; AND &amp;ff00)-KScsu_UC0&amp;)/&amp;0100<br>
&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;// go one byte back<br>
&nbsp;&nbsp;&nbsp;&nbsp;pIn&amp;=pIn&amp;-&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 1 inbytes used, 0 outbyte<br>
&nbsp;&nbsp;ELSEIF Char16&amp;&gt;=KScsu_UD0&amp; AND Char16&amp;&lt;=(KScsu_UD7&amp;+&amp;ff)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// set window locking<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=((Char16&amp; AND &amp;ff00)-KScsu_UD0&amp;)/&amp;0100<br>
&nbsp;&nbsp;&nbsp;&nbsp;// leave unicodemode<br>
&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;// go back one byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;pIn&amp;=pIn&amp;-&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;// change offset of dynamic window according to second byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char8%=PEEKB(pIn&amp;) :pIn&amp;=pIn&amp;+&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=CvScsuDynamicWindow&amp;:(Char8%)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 3 inbytes used, 0 outbytes<br>
&nbsp;&nbsp;ELSEIF (Char16&amp; AND &amp;ff00)=KScsu_UQU&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// go back one byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;pIn&amp;=pIn&amp;-&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=PeekWordBE&amp;:(pIn&amp;) :pIn&amp;=pIn&amp;+2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// store in outbuffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;PokeWordLE:(pOut&amp;,Char16&amp;) :pOut&amp;=pOut&amp;+&amp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 3 inbytes used, 2 outbyte<br>
&nbsp;&nbsp;ELSEIF (Char16&amp; AND &amp;ff00)=KScsu_UDX&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// go back one byte<br>
&nbsp;&nbsp;&nbsp;&nbsp;pIn&amp;=pIn&amp;-&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;Char16&amp;=PeekWordBE&amp;:(pIn&amp;) :pIn&amp;=pIn&amp;+2<br>
&nbsp;&nbsp;&nbsp;&nbsp;// set window based on the top three bits<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowN%=(Char16&amp; AND &amp;e000)/&amp;2000<br>
&nbsp;&nbsp;&nbsp;&nbsp;// calculate the new offset in expansion space based on remaining bits<br>
&nbsp;&nbsp;&nbsp;&nbsp;DynamicWindowOffset&amp;(DynamicWindowN%+1)=&amp;10000+(&amp;80*(Char16&amp; AND &amp;1fff))<br>
&nbsp;&nbsp;&nbsp;&nbsp;// the character will be interpreted in the next round so no<br>
&nbsp;&nbsp;&nbsp;&nbsp;// outbyte here<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 3 inbytes used, 0 outbytes<br>
&nbsp;&nbsp;&nbsp;&nbsp;// leave unicodemode<br>
&nbsp;&nbsp;&nbsp;&nbsp;UnicodeModeB%=KFalse%<br>
&nbsp;&nbsp;ELSEIF (Char16&amp; AND &amp;ff00)=KScsu_UR&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;U Reserved&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbyte used, 0 outbytes<br>
&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;bad U character: &quot;+HEX$(Char16&amp;))<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ---- 2 inbyte used, 0 outbytes<br>
&nbsp;&nbsp;ENDIF<br>
        ENDWH<br>
        // adjust size of outbuffer, since it may have been reduced or increased<br>
        pOutStart&amp;=REALLOC(pOutStart&amp;,TextSize&amp;)<br>
        // cleanup and set return BYREF values<br>
        FREEALLOC(pInStart&amp;)<br>
        POKEL _pText&amp;,pOutStart&amp;<br>
        POKEL _TextSize&amp;,TextSize&amp;<br>
        ENDP<br>
        <br>
      PROC CvScsuDynamicWindow&amp;:(aByte%)<br>
        // returns new dynamic window offset for the SDn commands<br>
        IF aByte%&gt;=$01 AND aByte%&lt;=$67<br>
&nbsp;&nbsp;RETURN (aByte%*$80+KScsuDynamicWindowLowOffset&amp;)<br>
ELSEIF aByte%&gt;=$68 AND aByte%&lt;=$a7<br>
&nbsp;&nbsp;RETURN (aByte%*$80+KScsuDynamicWindowHighOffset&amp;)<br>
        ELSEIF aByte%=$f9<br>
&nbsp;&nbsp;RETURN KScsuDynamicWindowLatin1x&amp;<br>
        ELSEIF aByte%=$fa<br>
&nbsp;&nbsp;RETURN KScsuDynamicWindowIpaExt&amp;<br>
        ELSEIF aByte%=$fb<br>
&nbsp;&nbsp;RETURN KScsuDynamicWindowGreek&amp;<br>
        ELSEIF aByte%=$fc<br>
&nbsp;&nbsp;RETURN KScsuDynamicWindowArmenian&amp;<br>
        ELSEIF aByte%=$fd<br>
&nbsp;&nbsp;RETURN KScsuDynamicWindowHiragana&amp;<br>
        ELSEIF aByte%=$fe<br>
&nbsp;&nbsp;RETURN KScsuDynamicWindowKatakana&amp;<br>
        ELSEIF aByte%=$ff<br>
&nbsp;&nbsp;RETURN KScsuDynamicWindowHalfKatakana&amp;<br>
        ELSE<br>
&nbsp;&nbsp;// $A8..$F8 are reserved<br>
&nbsp;&nbsp;// $00 is reserved<br>
&nbsp;&nbsp;RETURN &amp;00000000<br>
        ENDIF<br>
        ENDP<br>
        <br>
      PROC CvScsuStaticWindowInitialise:(_StaticWindowArray&amp;)<br>
        // Initialises StaticWindow offset array to default values<br>
        // Usage: CvScsuStaticWindowInitialise:(ADDR(WindowArray()))<br>
        POKEL _StaticWindowArray&amp;+&amp;0000,KScsuStaticWindow0&amp; // SW0<br>
        POKEL _StaticWindowArray&amp;+&amp;0004,KScsuStaticWindow1&amp; // SW1<br>
        POKEL _StaticWindowArray&amp;+&amp;0008,KScsuStaticWindow2&amp; // SW2<br>
        POKEL _StaticWindowArray&amp;+&amp;000c,KScsuStaticWindow3&amp; // SW3<br>
        POKEL _StaticWindowArray&amp;+&amp;0010,KScsuStaticWindow4&amp; // SW4<br>
        POKEL _StaticWindowArray&amp;+&amp;0014,KScsuStaticWindow5&amp; // SW5<br>
        POKEL _StaticWindowArray&amp;+&amp;0018,KScsuStaticWindow6&amp; // SW6<br>
        POKEL _StaticWindowArray&amp;+&amp;001c,KScsuStaticWindow7&amp; // SW7<br>
        ENDP<br>
        <br>
      PROC CvScsuDynamicWindowInitialise:(_DynamicWindowArray&amp;)<br>
        // initialises DynamicWindow offset array to default values<br>
        // Usage: CvScsuDynamicWindowInitialise:(ADDR(WindowArray()))<br>
        POKEL _DynamicWindowArray&amp;+&amp;0000,KScsuDynamicWindow0&amp; // DW0<br>
        POKEL _DynamicWindowArray&amp;+&amp;0004,KScsuDynamicWindow1&amp; // DW1<br>
        POKEL _DynamicWindowArray&amp;+&amp;0008,KScsuDynamicWindow2&amp; // DW2<br>
        POKEL _DynamicWindowArray&amp;+&amp;000c,KScsuDynamicWindow3&amp; // DW3<br>
        POKEL _DynamicWindowArray&amp;+&amp;0010,KScsuDynamicWindow4&amp; // DW4<br>
        POKEL _DynamicWindowArray&amp;+&amp;0014,KScsuDynamicWindow5&amp; // DW5<br>
        POKEL _DynamicWindowArray&amp;+&amp;0018,KScsuDynamicWindow6&amp; // DW6<br>
        POKEL _DynamicWindowArray&amp;+&amp;001c,KScsuDynamicWindow7&amp; // DW7<br>
        ENDP</font><font size="-1"><font size="-1" face="Arial, Helvetica, sans-serif"><font size="-1"><font color="#000080"><br>
        <br>
        </font></font></font></font></p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0023" id="dpNote0023"></a></b></font></b><font color="#000080">dpNote 
        0023</font></b></font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">8 April 2006 <br>
        <br>
        All OPL versions </font></font></td>
    <td><p><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Clipboard - accurate copying and pasting of text in ER6 and ER7 <br>  
        <br>  
      </font></b><font face="Arial, Helvetica, sans-serif" color="#000080">The clipboard in ER6 and later uses essentially the same format as the clipboard in ER5 and earlier. They key difference is that text is stored in SCSU format in ER6 and ER7 (Note: <strong>not</strong> Unicode UTF-16, see <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0022">dpNote 0022</a> about this) rather than ASCII as was the case with ER5.<br>
        <br>
        To date I have not found any need to develop clipboard routines for anything else than plain text. Perhaps in the future I will. However, contrary to most other OPL routies for clipboard handling that I've seen, I found it important to support texts with length far longer than 255. Hence the clipboard routines presented here use buffers, not strings.
        </font></font><font size="-1" face="Courier New, Courier, monospace"><br>
        <br>
        // these are constants for ER6/S80 (ER5 constants in brackets)<br>
        // it has been verified that the clipboard format is the same in<br>
        // S80 R1, S80 R2 and S90 as well as UIQ2<br>
        CONST KCbClipboardFile$=&quot;C:\System\Data\Clpboard.cbd&quot;<br>
        CONST KCbUid1&amp;=&amp;10000037   // UID1 - file header structure (ER5 same)<br>
        CONST KCbUid2&amp;=&amp;10003a10   // UID2 - file type (ER5 &amp;1000003b) <br>
        CONST KCbUid3&amp;=&amp;00000000   // UID3 - application identifier (ER5 same)<br>
        CONST KCbUid4&amp;=&amp;037bfc6a   // UID4 - checksum (ER5 &amp;4739d53b)<br>
        CONST KCbOffsetOfContentsTableOffset&amp;=&amp;00000010	// (ER5 same)<br>
        CONST KCbTextLenOffset&amp;=&amp;00000014	// (ER5 same)<br>
        CONST KCbContentsTableOffset&amp;=&amp;00000019	// (ER5 same)<br>
        CONST KCbNulByte%=$00	// (ER5 same)<br>
        CONST KCbNoOfContentsTableEntries%=$02 // (ER5 same)<br>
        CONST KCbObjectUidText&amp;=&amp;10003a1d	// UID for SCSU text (ER5 &amp;10000033)<br>
        <br>
        PROC CbCopyTo:(apSource&amp;,aSourceLength&amp;,aSourceSize&amp;)<br>
        // writes the content of a UTF-16LE buffer to the clipboard's text segment<br>
        // converts the text to SCSU <br>
        LOCAL hClipboard%,IoMode%,IoRtn%,pPos&amp;,pContentTableOffset&amp;<br>
        LOCAL pText&amp;,TextLength&amp;,TextSize&amp;<br>
        // Values<br>
        pText&amp;=apSource&amp;<br>
        TextLength&amp;=aSourceLength&amp;<br>
        TextSize&amp;=aSourceSize&amp;<br>
        IF TextLength&amp;&lt;&gt;TextSize&amp;/2<br>
        &nbsp;&nbsp;RAISE KErrInvalidFormat%<br>
        &nbsp;&nbsp;RETURN<br>
        ENDIF 
        <br>
        // Open the clipboard file for writing to<br>
        IoMode%=KIoAccessUpdate% OR KIoAccessRandom% OR KIoModeReplace% OR KIoFormatBinary%<br>
        IoRtn%=IOOPEN(hClipboard%,KCbClipboardFile$,IoMode%)<br>
        IF IoRtn%&lt;0<br>
        &nbsp;&nbsp;RAISE KErrInUse%<br>
        &nbsp;&nbsp;RETURN<br>
        ENDIF<br>
        // Write the clipboard header<br>
        IoWriteLong:(hClipboard%,KCbUid1&amp;)<br>
        IoWriteLong:(hClipboard%,KCbUid2&amp;)<br>
        IoWriteLong:(hClipboard%,KCbUid3&amp;)<br>
        IoWriteLong:(hClipboard%,KCbUid4&amp;)<br>
        // Write dummy table offset for now, fill in later<br>
        IoWriteLong:(hClipboard%,&amp;00000000)<br>
        // Store the buffer Length&amp;<br>
        IoWriteLong:(hClipboard%,TextLength&amp;)<br>
        // Encode into SCSU<br>
CvUnicodeToScsu:((ADDR(pText&amp;),TextLength&amp;,ADDR(TextSize&amp;))<br>
        // Actually store the text<br>
        IF TextSize&amp;&gt;KIoReadWriteChunk&amp;<br>
&nbsp;&nbsp;IoWriteBuffer:(hClipboard%,pText&amp;,TextSize&amp;)<br>
        ELSE<br>
&nbsp;&nbsp;IOWRITE(hClipboard%,pText&amp;,TextSize&amp;)<br>
        ENDIF<br>
        // Store a nul byte<br>
        IoWriteByte:(hClipboard%,KCbNulByte%)<br>
        // Remember table offset<br>
        // pPos&amp; will take the value of the current position<br>
        pPos&amp;=0<br>
        IOSEEK(hClipboard%,KIoPosRelative%,pPos&amp;)<br>
        // write the contents table<br>
        IoWriteByte:(hClipboard%,KCbNoOfContentsTableEntries%)  // two entries<br>
        IoWriteLong:(hClipboard%,KCbObjectUidText&amp;) // text UID<br>
        IoWriteLong:(hClipboard%,KCbTextLenOffset&amp;) // file offset<br>
        // seek back to the contents table offset position<br>
        pContentTableOffset&amp;=KCbOffsetOfContentsTableOffset&amp;<br>
        IOSEEK(hClipboard%,KIoPosAbsolute%,pContentTableOffset&amp;)<br>
        // write the content table offset<br>
        IoWriteLong:(hClipboard%,pPos&amp;)<br>
        // complete<br>
        IOCLOSE(hClipboard%)<br>
        ENDP<br>
        <br>
        PROC CbPasteFrom:(_pText&amp;,_TextLength&amp;,_TextSize&amp;)<br>
        // pastes clipboard text as UTF-16LE into a buffer pText&amp;,TextLength&amp;,TextSize&amp;    <br>
        // Usage: CbPasteFrom:(ADDR(pText&amp;),ADDR(TextLength&amp;),ADDR(TextSize&amp;))<br>
        // Note: if reading successful the procedure will allocate a buffer<br>
        // pText&amp;. If the buffer is not allocated pText&amp;=0<br>
        LOCAL hClipboard%,IoMode%,Offset&amp;,NoOfEntries%,ObjectUid&amp;,ObjectOffset&amp;<br>
        LOCAL i%,TextLength&amp;,TextSize&amp;,pText&amp;,TableOffset&amp;<br>
        // open the clipboard file<br>
        IF NOT EXIST(KCbClipboardFile$)<br>
&nbsp;&nbsp;TextSize&amp;=0<br>
&nbsp;&nbsp;pText&amp;=0<br>
&nbsp;&nbsp;GOTO LBL_CleanupAndReturn::<br>
        ENDIF<br>
        IoMode%=KIoAccessRandom% OR KIoModeOpen% OR KIoFormatBinary%<br>
        IOOPEN(hClipboard%,KCbClipboardFile$,IoMode%)<br>
        // obtain the offset to the contents table<br>
        Offset&amp;=KCbOffsetOfContentsTableOffset&amp;<br>
        IOSEEK(hClipboard%,KIoPosAbsolute%,Offset&amp;)<br>
        IOREAD(hClipboard%,ADDR(TableOffset&amp;),KLongSize&amp;)<br>
        // move pointer to the contents table<br>
        IOSEEK(hClipboard%,KIoPosAbsolute%,TableOffset&amp;)<br>
        // read number of entries in clipboard and exit if empty<br>
        IOREAD(hClipboard%,ADDR(NoOfEntries%),KByteSize&amp;)<br>
        IF NoOfEntries%=0<br>
&nbsp;&nbsp;TextSize&amp;=0<br>
&nbsp;&nbsp;pText&amp;=0<br>
&nbsp;&nbsp;GOTO LBL_CleanupAndReturn::<br>
        ENDIF<br>
        // read onwards until a text object is found<br>
        i%=0<br>
        DO<br>
&nbsp;&nbsp;IOREAD(hClipboard%,ADDR(ObjectUid&amp;),KLongSize&amp;)<br>
&nbsp;&nbsp;IOREAD(hClipboard%,ADDR(ObjectOffset&amp;),KLongSize&amp;)<br>
&nbsp;&nbsp;i%=i%+2<br>
UNTIL (i%&gt;NoOfEntries%) OR (ObjectUid&amp;=KCbObjectUidText&amp;)<br>
        // exit with zero size if no text found<br>
        IF i%&gt;NoOfEntries%<br>
&nbsp;&nbsp;pText&amp;=0<br>
&nbsp;&nbsp;TextSize&amp;=0<br>
&nbsp;&nbsp;GOTO LBL_CleanupAndReturn::<br>
        ENDIF<br>
        // set pointer to the start of the text object<br>
        IOSEEK(hClipboard%,KIoPosAbsolute%,ObjectOffset&amp;)<br>
        // determine the length of the text to be copied<br>
        IOREAD(hClipboard%,ADDR(TextLength&amp;),KLongSize&amp;)<br>
        // set a trial TextSize&amp; to cover worst case SCSU, and check so that<br>
        // the trial text does not overlap the table. the &amp;0004 is for the<br>
        // length field<br>
        TextSize&amp;=TextLength&amp;*3<br>
        IF (ObjectOffset&amp;+TextSize&amp;+&amp;4)&gt;TableOffset&amp;<br>
&nbsp;&nbsp;TextSize&amp;=TableOffset&amp;-ObjectOffset&amp;-&amp;0004<br>
        ENDIF<br>
        // read text into buffer<br>
        pText&amp;=ALLOC(TextSize&amp;)<br>
        IF TextSize&amp;&gt;KIoReadWriteChunk&amp;<br>
&nbsp;&nbsp;IoReadBuffer:(hClipboard%,pText&amp;,TextSize&amp;)<br>
        ELSE<br>
&nbsp;&nbsp;IOREAD(hClipboard%,pText&amp;,TextSize&amp;)<br>
        ENDIF<br>
        // convert to SCSU imposing actual length<br>
        CvScsuToUnicode:(ADDR(pText&amp;),TextLength&amp;,ADDR(TextSize&amp;))<br>
        // <br>
        LBL_CleanupAndReturn::<br>
        // close file<br>
        IOCLOSE(hClipboard%)<br>
        // return BYREF values<br>
        POKEL _pText&amp;,pText&amp;<br>
        POKEL _TextLength&amp;,TextLength&amp;<br>
        POKEL _TextSize&amp;,TextSize&amp;<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0024" id="dpNote0024"></a></b></font></b><font color="#000080">dpNote 0024<br>
            <br>
    </font></b><font color="#000080">31 Dec 2005 <br>
    <br>
All OPL versions </font></font></td>
    <td><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Adding a bitmap to an MBM file <br>
    </font></b><font size="-1"><br>
    </font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">This procedure adds a bitmap to an existing MBM file. It makes use of several procedures in dpNote0001 and dpNote0008.</font></font><br>
    <font size="-1" face="Courier New, Courier, monospace"><br>
PROC MbmFileAdd%:(aFileName$,aId%)<br>
// Adds a bitmap with the ID aId% into an MBM file aFileName$. If the MBM file<br>
// does not exist, a new MBM file is created.<br>
LOCAL IsValidMbmFileB%,hMbm%,Uid&amp;(4)<br>
LOCAL TempFile$(KMaxFileNameLen%),hTemp%,pTempBuffer&amp;,TempSize&amp;<br>
LOCAL Offset&amp;,oJumpTable&amp;,NoOfBitmaps&amp;,Index&amp;,pJumpTableStack&amp;,oNewBitmap&amp;<br>
// check the Mbm file that it is valid and contains at least one bitmap<br>
IF NOT EXIST(aFileName$)<br>
&nbsp;&nbsp;IsValidMbmFileB%=KFalse%<br>
&nbsp; GOTO LBL_Save::<br>
ENDIF<br>
hMbm%=IoOpenForRead%:(aFileName$)<br>
// verify that the header is an Mbm file header<br>
IOREAD(hMbm%,ADDR(Uid&amp;(1)),KLongSize&amp;) <br>
IOREAD(hMbm%,ADDR(Uid&amp;(2)),KLongSize&amp;)<br>
IOREAD(hMbm%,ADDR(Uid&amp;(3)),KLongSize&amp;)<br>
IOREAD(hMbm%,ADDR(Uid&amp;(4)),KLongSize&amp;)<br>
IOCLOSE(hMbm%)<br>
IF Uid&amp;(1)&lt;&gt;KUidLayoutPermanentFile&amp;<br>
&nbsp;&nbsp;IsValidMbmFileB%=KFalse%<br>
ELSEIF Uid&amp;(2)&lt;&gt;KUidFileTypeMbmER5&amp;<br>
&nbsp;&nbsp;IsValidMbmFileB%=KFalse%<br>
// Also verify that the mbm file has at least one bitmap<br>
ELSEIF MbmFileNoOfImages%:(aFileName$)&lt;1<br>
&nbsp; IsValidMbmFileB%=KFalse%<br>
ELSE<br>
&nbsp; IsValidMbmFileB%=KTrue%<br>
ENDIF<br>
LBL_Save::<br>
IF NOT IsValidMbmFileB%<br>
&nbsp; // Save file as single Mbm<br>
&nbsp;&nbsp;IF EXIST(aFileName$)<br>
&nbsp;&nbsp;&nbsp;&nbsp;DELETE(aFileName$)<br>
 &nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;gUSE aId%<br>
&nbsp;&nbsp;gSAVEBIT aFileName$<br>
&nbsp;&nbsp;// Ensure the file has the correct UID. This is necessary since gSAVEBIT will<br>
&nbsp;&nbsp;// set UID2 to KUidFileTypeSavedFromOplER5&amp;<br>
&nbsp;&nbsp;hMbm%=IoOpenForUpdate%:(aFileName$)<br>
&nbsp;&nbsp;Uid&amp;(1)=KUidLayoutPermanentFile&amp;<br>
&nbsp;&nbsp;Uid&amp;(2)=KUidFileTypeMbmER5&amp;<br>
&nbsp;&nbsp;Uid&amp;(3)=&amp;00000000<br>
&nbsp;&nbsp;Uid&amp;(4)=UidCheckSum&amp;:(Uid&amp;(1),Uid&amp;(2),Uid&amp;(3))<br>
&nbsp;&nbsp;IoWriteLong:(hMbm%,Uid&amp;(1))<br>
&nbsp;&nbsp;IoWriteLong:(hMbm%,Uid&amp;(2))<br>
&nbsp;&nbsp;IoWriteLong:(hMbm%,Uid&amp;(3))<br>
&nbsp;&nbsp;IoWriteLong:(hMbm%,Uid&amp;(4))<br>
&nbsp;&nbsp;IOCLOSE(hMbm%)<br>
ELSE 	// add the single Mbm onto the multi Mbm<br>
&nbsp;&nbsp;// first store as temporary bitmap<br>
&nbsp; TempFile$=IoCreateTemporaryFileName$:<br>
&nbsp; gUSE aId%<br>
&nbsp; gSAVEBIT TempFile$<br>
&nbsp; // read in size of saved bitmap<br>
&nbsp; hTemp%=IoOpenForRead%:(TempFile$)<br>
&nbsp; Offset&amp;=&amp;00000010<br>
&nbsp; IOSEEK(hTemp%,KIoPosAbsolute%,Offset&amp;)<br>
&nbsp; IOREAD(hTemp%,ADDR(oJumpTable&amp;),KLongSize&amp;)<br>
&nbsp; TempSize&amp;=oJumpTable&amp;-&amp;00000014<br>
&nbsp; // allocate temporary buffer and read in the bitmap<br>
&nbsp; pTempBuffer&amp;=ALLOC(TempSize&amp;)<br>
&nbsp; IoPositionSet:(hTemp%,&amp;00000014)<br>
&nbsp; IoReadBuffer:(hTemp%,pTempBuffer&amp;,TempSize&amp;)<br>
&nbsp; // open the Mbmfile and read in data subject to updates<br>
&nbsp; hMbm%=IoOpenForUpdate%:(aFileName$)<br>
&nbsp;&nbsp;Offset&amp;=&amp;00000010<br>
&nbsp;&nbsp;IOSEEK(hMbm%,KIoPosAbsolute%,Offset&amp;)<br>
&nbsp;&nbsp;IOREAD(hMbm%,ADDR(oJumpTable&amp;),KLongSize&amp;)<br>
&nbsp;&nbsp;IOSEEK(hMbm%,KIoPosAbsolute%,oJumpTable&amp;)<br>
&nbsp; IOREAD(hMbm%,ADDR(NoOfBitmaps&amp;),KLongSize&amp;)<br>
&nbsp; Index&amp;=&amp;1<br>
&nbsp; pJumpTableStack&amp;=StackLongCreate&amp;:<br>
&nbsp; WHILE Index&amp;&lt;=NoOfBitmaps&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;IOREAD(hMbm%,ADDR(Offset&amp;),KLongSize&amp;) 		&nbsp;&nbsp;&nbsp;&nbsp;pJumpTableStack&amp;=StackLongPush&amp;:(pJumpTableStack&amp;,Offset&amp;)<br>
&nbsp;&nbsp;&nbsp; Index&amp;=Index&amp;+&amp;1<br>
&nbsp; ENDWH<br>
&nbsp; // Append the temp file to the Mbmfile<br>
&nbsp; // The offset of the added bitmap takes the offset of the old jumptable<br>
&nbsp; oNewBitmap&amp;=oJumpTable&amp;<br>
&nbsp;&nbsp;IoPositionSet:(hMbm%,oNewBitmap&amp;)<br>
&nbsp; IoWriteBuffer:(hMbm%,pTempBuffer&amp;,TempSize&amp;)<br>
&nbsp; // update jumptable offsets and no of bitmaps<br>
&nbsp; oJumpTable&amp;=IoPosition&amp;:(hMbm%)<br>
&nbsp; NoOfBitmaps&amp;=NoOfBitmaps&amp;+&amp;1<br>
&nbsp; // write the new jumptable<br>
&nbsp; IoWriteLong:(hMbm%,NoOfBitmaps&amp;)<br>
&nbsp; StackLongMirror:(pJumpTableStack&amp;)<br>
&nbsp;&nbsp;WHILE (NOT StackLongEmptyB%:(pJumpTableStack&amp;))<br>
&nbsp;&nbsp;&nbsp;&nbsp;Offset&amp;=StackLongPop&amp;:(pJumpTableStack&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;IoWriteLong:(hMbm%,Offset&amp;)<br>
&nbsp; ENDWH<br>
&nbsp; IoWriteLong:(hMbm%,oNewBitmap&amp;)<br>
&nbsp;&nbsp;// write the new jumptable offset<br>
&nbsp;&nbsp;IoPositionSet:(hMbm%,&amp;00000010)<br>
&nbsp;&nbsp;IoWriteLong:(hMbm%,oJumpTable&amp;)<br>
&nbsp; // cleanup<br>
&nbsp; StackLongDestroy:(pJumpTableStack&amp;)<br>
&nbsp; IoCloseTemporary:(TempFile$,hTemp%)<br>
&nbsp; IOCLOSE(hMbm%)<br>
&nbsp; FREEALLOC(pTempBuffer&amp;)<br>
ENDIF<br>
// return the number of Mbms in the file<br>
RETURN MbmFileNoOfImages%:(aFileName$) // from dpNote 0001 <br>
ENDP</font></td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0025" id="dpNote0025"></a></b></font></b><font color="#000080">dpNote 
        0025</font></b></font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">20 July 2005 <br>
        <br>
        All OPL versions </font></font></td>
    <td><p><b><font color="#000080" size="-1" face="Arial, Helvetica, sans-serif">Useful IO functions and wrappers<br>
        </font></b><font color="#000080" size="-1" face="Arial, Helvetica, sans-serif"><br>
        These IO functions and wrappers are used by many other dpNote program examples.  <br>  
        <b><br>
        </b></font><font color="#000000" size="-1" face="Courier New, Courier, monospace">PROC IoOpenForRead%:(aFileName$)<br>
          // opens a file for reading <br>
        LOCAL IoMode%,IoRtn%,hFile%<br>
        IoMode%=KIoModeOpen% OR KIoFormatBinary% OR KIoAccessRandom% OR KIoAccessShare%<br>
        IoRtn%=IOOPEN(hFile%,aFileName$,IoMode%)<br>
        IF IoRtn%&lt;0<br>
  &nbsp;&nbsp;RAISE IoRtn%<br>
  &nbsp;&nbsp;RETURN 0<br>
        ENDIF<br>
        RETURN hFile%<br>
        ENDP<br>    
        <br>
        PROC IoOpenForUpdate%:(aFileName$)<br>
        // opens a file for editing <br>
          LOCAL IoMode%,IoRtn%,hFile%<br>
          IoMode%=KIoModeOpen% OR KIoFormatBinary% OR KIoAccessUpdate% OR KIoAccessRandom%<br>
          IoRtn%=IOOPEN(hFile%,aFileName$,IoMode%)<br>
          IF IoRtn%&lt;0<br>
  &nbsp;&nbsp;RAISE IoRtn%<br>
  &nbsp;&nbsp;RETURN 0<br>
          ENDIF<br>
          RETURN hFile%<br>
          ENDP<br>    
          <br>
          PROC IoOpenForWrite%:(aFileName$)<br>
          // opens a file for replacing <br>
            LOCAL IoMode%,IoRtn%,hFile%<br>
            IoMode%=KIoModeReplace% OR KIoFormatBinary% OR KIoAccessRandom% OR KIoAccessUpdate%<br>
            IoRtn%=IOOPEN(hFile%,aFileName$,IoMode%)<br>
            IF IoRtn%&lt;0<br>
  &nbsp;&nbsp;RAISE IoRtn%<br>
            RETURN 0<br>
            ENDIF<br>
            RETURN hFile%<br>
            ENDP<br>    
            <br>
            PROC IoOpenTemporary$:(_hFile&amp;)<br>
              // Returns a generated temporary filename<br>
              // Opens the temporary file for writing and returns the handle as hFile%<br>
              // Usage: TempFile$=IoOpenTemporary$:(ADDR(hFile%))<br>
              LOCAL IoMode%,IoRtn%,hFile%,FilePath$(KMaxFileNameLen%)<br>
              FilePath$=&quot;C:\System\Temp\&quot;<br>
              IF NOT EXIST(FilePath$)<br>
  &nbsp;&nbsp;MKDIR(FilePath$)<br>
              ENDIF<br>
              IoMode%=KIoAccessUpdate% OR KIoAccessRandom% OR KIoModeUnique% OR KIoFormatBinary%<br>
              IoRtn%=IOOPEN(hFile%,ADDR(FilePath$),IoMode%)<br>
              IF IoRtn%&lt;0<br>
  &nbsp;&nbsp;POKEL _hFile&amp;,$0000<br>
  &nbsp;&nbsp;RAISE IoRtn%<br>
  &nbsp;&nbsp;RETURN &quot;&quot;<br>
              ENDIF<br>
              // return BYREF value<br>
              POKEL _hFile&amp;,hFile%<br>
              // return the temporary filename<br>
              RETURN FilePath$<br>
              ENDP<br>    
              <br>
              PROC IoCloseTemporary:(aFileName$,aHandle%)<br>
                // closes and deletes a temporary file opened with IoOpenTemporary$:(_hFile&amp;)<br>
                IOCLOSE(aHandle%)<br>
                IF EXIST(aFileName$)<br>
  &nbsp;&nbsp;TRAP DELETE aFileName$<br>
                ENDIF<br>
                ENDP<br>    
                <br>
                PROC IoCreateTemporaryFileName$:<br>
                  // Returns a generated temporary filename<br>
                  // Usage: TempFile$=IoCreateTemporaryFileName$:<br>
                  LOCAL IoMode%,IoRtn%,hFile%,FilePath$(KMaxFileNameLen%)<br>
                  FilePath$=&quot;C:\System\Temp\&quot;<br>
                  IF NOT EXIST(FilePath$)<br>
  &nbsp;&nbsp;MKDIR(FilePath$)<br>
                  ENDIF<br>
                  IoMode%=KIoAccessUpdate% OR KIoAccessRandom% OR KIoModeUnique% OR KIoFormatBinary%<br>
                  IoRtn%=IOOPEN(hFile%,ADDR(FilePath$),IoMode%)<br>
                  IF IoRtn%&lt;0<br>
  &nbsp;&nbsp;RAISE IoRtn%<br>
  &nbsp;&nbsp;RETURN &quot;&quot;<br>
                  ENDIF<br>
                  IOCLOSE(hFile%)<br>
                  RETURN FilePath$<br>
                  ENDP<br>    
                  <br>
                  PROC IoEofB%:(aHandle%)<br>
                    // returns KTrue% if the reading of file has reached the last byte, else KFalse%<br>
                    LOCAL EndOffset&amp;,PreviousOffset&amp;<br>
                    // get current position<br>
                    PreviousOffset&amp;=&amp;00000000<br>
                    IOSEEK(aHandle%,KIoPosRelative%,PreviousOffset&amp;)<br>
                    // get end position<br>
                    EndOffset&amp;=&amp;00000000<br>
                    IOSEEK(aHandle%,KIoPosFromEnd%,EndOffset&amp;)<br>
                    // if current and end positions are the same, it means we're at the<br>
                    // end of file<br>
                    IF PreviousOffset&amp;&gt;=EndOffset&amp;<br>
  &nbsp;&nbsp;RETURN KTrue%<br>
                    ELSE<br>
  &nbsp;&nbsp;// set position back to current<br>
  &nbsp;&nbsp;IOSEEK(aHandle%,KIoPosAbsolute%,PreviousOffset&amp;)<br>
  &nbsp;&nbsp;RETURN KFalse%<br>
                    ENDIF<br>
                    ENDP<br>    
                    <br>
                    PROC IoPosition&amp;:(aHandle%)<br>
                      // returns the current read-pointer to the opened IO file<br>
                      LOCAL Offset&amp;<br>
                      // setting the offset to zero means that the pointer will not move in<br>
                      // any direction<br>
                      Offset&amp;=&amp;00000000<br>
                      IOSEEK(aHandle%,KIoPosRelative%,Offset&amp;)<br>
                      RETURN Offset&amp;<br>
                      ENDP<br>    
                      <br>
                      PROC IoPositionSet:(aHandle%,aPosition&amp;)<br>
                        // sets absolute position<br>
                        LOCAL Offset&amp;<br>
                        Offset&amp;=aPosition&amp;<br>
                        IOSEEK(aHandle%,KIoPosAbsolute%,Offset&amp;)<br>
                        ENDP<br>    
                        <br>
                        PROC IoPositionStart:(aHandle%)<br>
                          // sets pointer to start of the file
                        <br>
                          LOCAL Offset&amp;<br>
                          Offset&amp;=&amp;00000000 // first byte<br>
                          IOSEEK(aHandle%,KIoPosAbsolute%,Offset&amp;)<br>
                          ENDP<br>      
                          <br>
                          PROC IoReverse:(aHandle%,aBytes&amp;)<br>
                            // moves backwards a given number of bytes<br>
                            LOCAL Offset&amp;<br>
                            Offset&amp;=-ABS(aBytes&amp;)<br>
                            IOSEEK(aHandle%,KIoPosRelative%,Offset&amp;)<br>
                            ENDP<br>      
                            <br>
                            </font><font color="#000080" size="-1" face="Arial, Helvetica, sans-serif">One major issue in OPL text handing is that IOREAD and IOWRITE cannot handle large buffers. Instead they have to be read and written in chunks of  2000 bytes.</font><br>
                            <font color="#000000" size="-1" face="Courier New, Courier, monospace"><br>
                            CONST KIoReadWriteChunk&amp;=2000<br>
                            <br>
                            PROC IoWriteBuffer:(aHandle%,apBuffer&amp;,aBufferSize&amp;)<br>
                              // IO-writes long buffers. Assumes that the file has already been opened with<br>
                              // IOOPEN. Arguments are identical to IOWRITE<br>
                              LOCAL pCurrent&amp;,pEnd&amp;<br>
                              pCurrent&amp;=apBuffer&amp;<br>
                              pEnd&amp;=apBuffer&amp;+aBufferSize&amp;<br>
                              WHILE (pEnd&amp;-pCurrent&amp;)&gt;=KIoReadWriteChunk&amp;<br>
&nbsp;&nbsp;IOWRITE(aHandle%,pCurrent&amp;,KIoReadWriteChunk&amp;)<br>
&nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+KIoReadWriteChunk&amp;<br>
                              ENDWH<br>
                              IF pCurrent&amp;&lt;pEnd&amp;<br>
&nbsp;&nbsp;IOWRITE(aHandle%,pCurrent&amp;,pEnd&amp;-pCurrent&amp;)<br>
                              ENDIF<br>
                              ENDP<br>      
                              <br>
                              PROC IoReadBuffer:(aHandle%,apBuffer&amp;,aBufferSize&amp;)<br>
                                // IO-reads long buffers. Assumes that the file has already been opened with<br>
                                // IOOPEN. Arguments are identical to IOREAD<br>
                                LOCAL pCurrent&amp;,pEnd&amp;<br>
                                pCurrent&amp;=apBuffer&amp;<br>
                                pEnd&amp;=apBuffer&amp;+aBufferSize&amp;<br>
                                WHILE (pEnd&amp;-pCurrent&amp;)&gt;=KIoReadWriteChunk&amp;<br>
&nbsp;&nbsp;IOREAD(aHandle%,pCurrent&amp;,KIoReadWriteChunk&amp;)<br>
&nbsp;&nbsp;pCurrent&amp;=pCurrent&amp;+KIoReadWriteChunk&amp;<br>
                                ENDWH<br>
                                IF pCurrent&amp;&lt;pEnd&amp;<br>
&nbsp;&nbsp;IOREAD(aHandle%,pCurrent&amp;,pEnd&amp;-pCurrent&amp;)<br>
                                ENDIF<br>
                                ENDP<br>      
                                <br>
                              PROC IoFileToBuffer:(aFileName$,_pBuffer&amp;,_Size&amp;)<br>
            // loads a binary file into a buffer and returns the pointer to the buffer<br>
            LOCAL pIn&amp;,FileSize&amp;<br>
            LOCAL hFile%,IoMode%,r&amp;,return&amp;<br>
            // allocate buffer according to file size<br>
            FileSize&amp;=GetFileSize&amp;:(aFileName$)<br>
            pIn&amp;=ALLOC(FileSize&amp;+KIoReadWriteChunk&amp;)<br>
            // open file<br>
            IoMode%=KIoModeOpen% OR KIoFormatBinary% OR KIoAccessRandom%<br>
            IOOPEN(hFile%,aFileName$,IoMode%)<br>
            // load data chunkwise<br>
            r&amp;=0<br>
            DO<br>
&nbsp;&nbsp;return&amp;=IOREAD(hFile%,pIn&amp;+r&amp;*KIoReadWriteChunk&amp;,KIoReadWriteChunk&amp;)<br>
&nbsp;&nbsp;r&amp;=r&amp;+&amp;1<br>
            // the return value is equal to the number of bytes read-in<br>
            // when reaching end of file, return will be less than the chunk<br>
            UNTIL return&amp;&lt;&gt;KIoReadWriteChunk&amp;<br>
            // close file<br>
            IOCLOSE(hFile%)<br>
          // return BYREF values<br>
          POKEL _pBuffer&amp;,pIn&amp; <br>
          POKEL _Size&amp;,FileSize&amp;<br>
        ENDP<br>      
        <br>
            PROC IoLengthSListRead%:(aHandle%)<br>
          // the SList length is used in Symbian Word formats and probably many other<br>
          // Symbian/Psion formats. It allows lengths of:<br>
          // 00000000 - 0000007F and<br>
          // 00000080 - 00001FFF<br>
          LOCAL Byte%<br>
          IOREAD(aHandle%,ADDR(Byte%),KByteSize&amp;)<br>
          IF (Byte% AND $03)=$02<br>
&nbsp;&nbsp;RETURN (Byte%-$02)/$0004<br>
          ELSEIF (Byte% AND $07)=$05<br>
&nbsp;&nbsp;IoReverse:(aHandle%,KByteSize&amp;)<br>
&nbsp;&nbsp;IOREAD(aHandle%,ADDR(Byte%),KWordSize&amp;)<br>
&nbsp;&nbsp;RETURN (Byte%-$05)/$0008<br>
          ELSE<br>
&nbsp;&nbsp;RAISE KErrOutOfRange%<br>
&nbsp;&nbsp;RETURN $0000<br>
          ENDIF<br>
          ENDP<br>      
          <br>
            PROC IoLengthSListWrite:(aHandle%,aLength%)<br>
          // see IoLengthSListRead%:<br>
          LOCAL Length%<br>
          Length%=aLength%<br>
          IF Length%&lt;=$003f<br>
&nbsp;&nbsp;Length%=Length%*4+$02<br>
&nbsp;&nbsp;IOWRITE(aHandle%,ADDR(Length%),KByteSize&amp;)<br>
ELSEIF Length%&lt;=$1fff<br>
&nbsp;&nbsp;Length%=Length%*8+$05<br>
&nbsp;&nbsp;IOWRITE(aHandle%,ADDR(Length%),KWordSize&amp;)<br>
          ELSE<br>
&nbsp;&nbsp;RAISE KErrOutOfRange%<br>
          ENDIF<br>
          ENDP<br>      
          <br>
          PROC IoLengthXListRead&amp;:(aHandle%)<br>
          // the XList length is used in Symbian Word formats and probably many other<br>
          // Symbian/Psion formats. One example is the length indicator before the plain<br>
          // text field in Psion Word. The Xlist length can be 1 to 3 bytes long,<br>
          // depending on the value of the first byte. It allows lengths of:<br>
          // 00000000 - 0000007F    one byte<br>
          // 00000080 - 00003FFF    two bytes<br>
          // 00004000 - 1FFFFFFF    four bytes<br>
          // it could be assumed that even longer lengths could be represented using<br>
          // five bytes or more, but this is not covered here.<br>
          LOCAL Byte%,Long&amp;<br>
          IOREAD(aHandle%,ADDR(Byte%),KByteSize&amp;)<br>
          IF (Byte% AND $01)=$00<br>
&nbsp;&nbsp;RETURN (Byte%/&amp;00000002)<br>
          ELSEIF (Byte% AND $03)=$01<br>
&nbsp;&nbsp;IoReverse:(aHandle%,KByteSize&amp;)<br>
&nbsp;&nbsp;IOREAD(aHandle%,ADDR(Long&amp;),KWordSize&amp;)<br>
&nbsp;&nbsp;RETURN (Long&amp;-$01)/4<br>
          ELSEIF (Byte% AND $07)=$03<br>
&nbsp;&nbsp;IoReverse:(aHandle%,KByteSize&amp;)<br>
&nbsp;&nbsp;IOREAD(aHandle%,ADDR(Long&amp;),KLongSize&amp;)<br>
&nbsp;&nbsp;RETURN (Long&amp;-$03)/8<br>
          ELSE<br>
&nbsp;&nbsp;RAISE KErrOutOfRange%<br>
&nbsp;&nbsp;RETURN &amp;00000000<br>
          ENDIF<br>
          ENDP<br>        
          <br>
          PROC IoLengthXListWrite:(aHandle%,aLength&amp;)<br>
          // writes a XList length in 1 to 3 bytes, see IoLengthXListRead&amp;:<br>
          LOCAL Length&amp;<br>
          Length&amp;=aLength&amp;<br>
          IF Length&amp;&lt;=&amp;0000007f<br>
&nbsp;&nbsp;Length&amp;=Length&amp;*2<br>
&nbsp;&nbsp;IOWRITE(aHandle%,ADDR(Length&amp;),KByteSize&amp;)<br>
ELSEIF Length&amp;&lt;=&amp;00003fff<br>
&nbsp;&nbsp;Length&amp;=Length&amp;*4+$01<br>
&nbsp;&nbsp;IOWRITE(aHandle%,ADDR(Length&amp;),KWordSize&amp;)<br>
ELSEIF Length&amp;&lt;=&amp;1fffffff<br>
&nbsp;&nbsp;Length&amp;=Length&amp;*8+$03<br>
&nbsp;&nbsp;IOWRITE(aHandle%,ADDR(Length&amp;),KLongSize&amp;)<br>
          ELSE<br>
&nbsp;&nbsp;RAISE KErrOutOfRange%<br>
          ENDIF<br>
          ENDP<br>        
          <br>
            PROC IoWriteByte:(aHandle%,aByte%)<br>
          LOCAL LocalByte%<br>
          LocalByte%=aByte% AND $00ff<br>
          IOWRITE(aHandle%,ADDR(LocalByte%),KByteSize&amp;)<br>
          ENDP<br>        
          <br>
            PROC IoWriteShort:(aHandle%,aShort%)<br>
          LOCAL LocalShort%<br>
          LocalShort%=aShort%<br>
          IOWRITE(aHandle%,ADDR(LocalShort%),KShortSize&amp;)<br>
          ENDP<br>        
          <br>
          PROC IoWriteLong:(aHandle%,aLong&amp;)<br>
          LOCAL LocalLong&amp;<br>
          LocalLong&amp;=aLong&amp;<br>
          IOWRITE(aHandle%,ADDR(LocalLong&amp;),KLongSize&amp;)<br>
          ENDP<br>        
          <br>
            PROC IoWriteString:(aHandle%,aString$)<br>
          // note: only writes the character codes, length/size has to be written <br>
          // separately<br>
          LOCAL String$(KMaxStringLen%)<br>
          String$=aString$<br>
          IOWRITE(aHandle%,ADDR(String$)+KTextHeader%,LEN(String$))<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0026" id="dpNote0026"></a></b></font></b><font color="#000080">dpNote 
        0026</font></b></font><br>
        <br>
        <font face="Arial, Helvetica, sans-serif" size="-1"><font color="#000080">1 March 2007 <br>
        <br>
        All OPL versions </font></font></td>
    <td><font size="-1"><b><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Predictable PAUSE function<br>
      <br>
      </font></b></font></b><font size="-1"><font face="Arial, Helvetica, sans-serif" color="#000080">OPL's PAUSE command seems to have a few drawbacks. First it, can cause unpredictable behaviour when used within an asynchronous loop. Second, it appears to give different delays on different devices. Using the Date.opx, the following function solves both issues.</font></font> </font><font size="-1" face="Courier New, Courier, monospace"><br>
      <br>
      PROC WaitMilliseconds:(aMilliSecond&amp;)<br>
  LOCAL hTime1&amp;,hTime2&amp;,WaitTime&amp;<br>
  WaitTime&amp;=aMilliSecond&amp;*1000<br>
  hTime1&amp;=DtNow&amp;:<br>
      WHILE KTrue%<br>
      &nbsp;&nbsp;hTime2&amp;=DtNow&amp;:<br>
      &nbsp;&nbsp;IF DtMicrosDiff&amp;:(hTime1&amp;,hTime2&amp;)&gt;WaitTime&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;BREAK<br>
&nbsp;&nbsp;ENDIF<br>
ENDWH<br>
DtDeleteDateTime:(hTime1&amp;)<br>
DtDeleteDateTime:(hTime2&amp;)<br>
ENDP</font></td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0027" id="dpNote0027"></a></b></font></b><font color="#000080">dpNote 0027<br>
        <br>
    </font></b><font color="#000080">21 June 2001 <br>

<br>
 All OPL versions
</font></font></td>
    <td><p><font size="-1"><b><font size="-1"><b><font face="Arial, Helvetica, sans-serif" color="#000080">Launching an application from OPL and wait until it finishes before returning<br>
                  <br>
                  </font></b></font></b><font size="-1"><font face="Arial, Helvetica, sans-serif" color="#000080"><font face="arial" size="2"><font face="Arial">The following demonstrates how to launch a Word file then 'log on' to the returned thread and wait until it has been ended by the user before continuing. The code makes use of asynchronous event handling. </font></font><b><b><br>
                                </b></b></font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Courier New, Courier, mono"><br>
                                INCLUDE &quot;System.oxh&quot;<br>
    INCLUDE &quot;Const.oph&quot;<br>
    <br>
PROC Main:<br>
                                </font><font size="-1"><font size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Courier New, Courier, mono">RunEndReturn:(</font><font size="-1" face="Courier New, Courier, mono">&quot;C:\Documents\CloseMe&quot;</font><font face="Courier New, Courier, mono">)</font></font></font></font></font><font face="Courier New, Courier, mono"><br>
ENDP
<br>
<br>
PROC RunEndReturn:(aFilename$)
<br>
LOCAL File$(KMaxStringLen%),Ev&amp;(16),EventStatus%<br>
LOCAL ThreadID&amp;,ThreadStatus&amp; // For our Word thread</font></font></font></font></font><font size="-1" face="Courier New, Courier, mono"><br>
                                IF EXIST(aFilename$)<br>
        &nbsp;&nbsp;TRAP DELETE aFilename$<br>
        ENDIF<br>
        // Start Word and create the file.<br>
        // The OPL application is pushed to the background...<br>
        ThreadID&amp;=RunApp&amp;:(&quot;Word&quot;,aFilename$,&quot;&quot;,1)<br>
        // ...but we keep running, so keep an eye on the thread.<br>
        LogOnToThread:(ThreadID&amp;,ThreadStatus&amp;)<br>
        WHILE KTrue%<br>
  &nbsp;&nbsp;// Queue an async event read.<br>
  &nbsp;&nbsp;GETEVENTA32 EventStatus%,Ev&amp;()<br>
  &nbsp;&nbsp;PRINT &quot;IOWAITing...&quot;<br>
  &nbsp;&nbsp;IOWAIT<br>
  &nbsp;&nbsp;// Check for thread completion<br>
  &nbsp;&nbsp;IF ThreadStatus&amp;&lt;&gt;KStatusPending32&amp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;// We may still be in background,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;// so let someone know what's happened.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;BEEP 3,300<br>
  &nbsp;&nbsp;&nbsp;&nbsp;PRINT &quot;Word has finished.&quot;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;BREAK<br>
  &nbsp;&nbsp;// Check for other events<br>
&nbsp;&nbsp;ELSEIF EventStatus%&lt;&gt;KErrFilePending%<br>
  &nbsp;&nbsp;&nbsp;&nbsp;// Look at the event type...<br>
  &nbsp;&nbsp;&nbsp;&nbsp;IF Ev&amp;(KEvType%)=KEvFocusGained&amp; // foreground<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRINT &quot;We're in the foreground.&quot;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BREAK<br>
&nbsp;&nbsp;&nbsp;  ELSE<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRINT &quot;Other event&quot;,HEX$(Ev&amp;(KEvType%)),&quot;ignored.&quot;<br>
&nbsp;&nbsp;&nbsp;  ENDIF<br>
&nbsp;&nbsp;ENDIF<br>
ENDWH<br>
  PRINT &quot;Done.&quot;<br>
  GET<br>
                                ENDP<br>
                                <font face="Arial, Helvetica, sans-serif"><br>
                                <font color="#000080">From 
                                <font size="2">Symbian Knowledgebase FAQ-0412</font></font></font></font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0028"></a></b></font></b><font color="#000080">dpNote 
        0028<br>
        <br>
        </font></b><font color="#000080">1 June 2003<br>
        (updated with comments on 1 Oct 2003)<br>
        <br>
        v5 Eikon <br>
        v6 Series 80 R1 <br>
        </font></font></p>    </td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Asynchronous 
        event loop with inactivity timer</font></b></font><font size="-1"><br>
        <font face="Courier New, Courier, mono"><br>
        <font face="Arial, Helvetica, sans-serif" color="#000080">The following 
        is an application template which works both for v5/Eikon (in which we 
        have used this structure in several applications) and v6/S80 (in which 
        we have used it for one application). It has been tested on:<br>
        <br>
        </font></font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">- 
        Psion netBook (v5/Eikon)<br>
        - WINS for v5/Eikon<br>
        - WINS for v6/S80 R1 <br>
        - Nokia 9210 (v6/S80 R1)<br>
        <br>
        When running in v5/Eikon, it works as expected and no stray signals are 
        ever generated.<br>
        <br>
        When running in v6/S80 R1, lots of stray signals are generated. Furthermore, 
        if not two </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">IOSIGNAL</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        are added to the stray signal handling, the application will hang after 
        a while. Therefore, we had to add a </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">KAddSomeExtraIoSignalB%</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        which should be set to </font><font face="Courier New, Courier, mono" size="-1">KFalse%</font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        in v5/Eikon and to </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">KTrue%</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        in v6/S80 R1.<br>
        <br>
        We have not tried this in v6/S60, v7/S60, v7/UIQ, v7/S80 R2, nor v7/S90 
        yet.<br>
        <br>
        We think that asynchronous event handling is a very important part of 
        OPL. It has been indicated before that v6/S80 is quite flaky in this area 
        but we hope to be able to identify where the problems are in order to 
        make it better going forward. In particular, there is reportedly a buggy 
        timer.</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">// Asynchronous Event 
        Handling<br>
        // Getevent loop with inactivity timer<br>
        // - can be used for 'screensavers' etc<br>
        // 19/6/2003 Free2move Asia S/B<br>
        // www.f2m.com.my</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">INCLUDE &quot;Const.oph&quot;<br>
        INCLUDE &quot;System.oxh&quot;</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">// select platform 
        before compilation<br>
        rem CONST KSymbianOsVersion$=&quot;v5/Eikon&quot;<br>
        rem CONST KSymbianOsVersion$=&quot;v6/S60&quot;<br>
        CONST KSymbianOsVersion$=&quot;v6/S80&quot; <br>
        rem CONST KSymbianOsVersion$=&quot;v7/UIQ&quot;<br>
        rem CONST KSymbianOsVersion$=&quot;v7/S60&quot;<br>
        rem CONST KSymbianOsVersion$=&quot;v7/S80&quot;<br>
      rem CONST KSymbianOsVersion$=&quot;v7/S90&quot;<br>
      <br>
        CONST KTimeOut%=5 // 
        seconds<br>
        CONST KTimerStart&amp;=0 // reset timer<br>
        <br>
      // needs to be set 
        KTrue% for v6/S80 and to KFalse% for v5/Eikon<br>
        // otherwise application will hang<br>
        // but should not be needed were OPL for v6/S80 bugfree<br>
      CONST KAddSomeExtraIoSignalB%=KTrue%<br>
      <br>
      PROC Main:<br>
        LOCAL t$(KMaxStringLen%),a$(KMaxStringLen%),b$(KMaxStringLen%)<br>
        t$=&quot;Eventloop with non-activity timer&quot;<br>
        a$=&quot;This is a template for application&quot;+NewLine$:+&quot;development&quot;<br>
        b$=NewLine$:+&quot;This machine is: &quot;+GetMachineName$:<br>
        InfoDialogue:(t$,a$,b$)<br>
        EventLoopA:<br>
      ENDP<br>
      <br>
      PROC EventLoopA:<br>
      LOCAL ev&amp;(16),EventStatus%<br>
      LOCAL TimeOut&amp;,hTimer%,TimerStatus%,TimerReturn%<br>
        LOCAL StraySignalCount%<br>
        LOCAL ForeGroundB%<br>
        // program starts in foreground<br>
        ForeGroundB%=KTrue%<br>
        // reset stray signal counter<br>
        StraySignalCount%=0<br>
        // create a timer<br>
        IOOPEN(hTimer%,KIoTimer$,KIoModeDeviceOnly%)<br>
        // ensure at least one loop<br>
        ev&amp;(1)=0<br>
        // start getevent loop<br>
        WHILE ev&amp;(1)&lt;&gt;KKeyEsc%<br>
&nbsp;&nbsp;// set async<br>
&nbsp;&nbsp;GETEVENTA32 EventStatus%,ev&amp;()<br>
&nbsp;&nbsp;// set timer only if in foreground<br>
&nbsp;&nbsp;IF ForeGroundB%<br>
&nbsp;&nbsp;&nbsp;&nbsp;TimeOut&amp;=KTimeOut%*10<br>
&nbsp;&nbsp;&nbsp;&nbsp;TimerReturn%=IOC(hTimer%,1,TimerStatus%,TimeOut&amp;,#KTimerStart&amp;)<br>
&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;// wait for something to happen<br>
&nbsp;&nbsp;IOWAIT<br>
&nbsp;&nbsp;IF EventStatus%&lt;&gt;KStatusPending% // event<br>
&nbsp;&nbsp;&nbsp;&nbsp;// cancel timer only if in foreground, i.e. if 
        it has been<br>
&nbsp;&nbsp;&nbsp;&nbsp;// initialised earlier<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF ForeGroundB%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOCANCEL(hTimer%)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOWAITSTAT hTimer%<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;// handle input events<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF ev&amp;(KEvType%)=KEvFocusLost&amp; // program 
        moved to background<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;Disappearing...&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// option to have a HotKeyHandler: 
        procedure here<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ForeGroundB%=KFalse%<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSEIF ev&amp;(KEvType%)=KEvFocusGained&amp; // 
        program moved to foreground<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;Reappearing...&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ForeGroundB%=KTrue%<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSEIF ev&amp;(KEvType%)=KEvDateChanged&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;Tempus fugit...&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE // data input event<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (ev&amp;(KEvType%)&lt;&gt;KEvKeyDown&amp; 
        AND ev&amp;(KEvType%)&lt;&gt;KEvKeyUp&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (ev&amp;(KEvType%)&lt;&gt;KEvPtr&amp;) 
        AND (ev&amp;(KEvType%)&lt;&gt;KEvPtrEnter&amp;) AND (ev&amp;(KEvType%)&lt;&gt;KEvPtrExit&amp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// replaces 
        (ev&amp;(KEvType%) AND KEvNotKeyMask&amp;)=0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventKeyProcess:(ev&amp;(KEvType%),ev&amp;(KEvMod%),ev&amp;(KEvScan%))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventPenProcess:(ev&amp;(KEvWinID%),ev&amp;(KEvPtrType%),ev&amp;(KEvPtrX%),ev&amp;(KEvPtrY%))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;ELSEIF TimerStatus%&lt;&gt;KStatusPending% // time out<br>
&nbsp;&nbsp;&nbsp;&nbsp;GETEVENTC(EventStatus%)<br>
&nbsp;&nbsp;&nbsp;&nbsp;TimeOutProcess:<br>
&nbsp;&nbsp;ELSE // stray signal<br>
&nbsp;&nbsp;&nbsp;&nbsp;Message:(&quot;Stray signal count = &quot;+GEN$(StraySignalCount%,5))<br>
&nbsp;&nbsp;&nbsp;&nbsp;StraySignalCount%=StraySignalCount%+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;GETEVENTC(EventStatus%)<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF ForeGroundB%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOCANCEL(hTimer%)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOWAITSTAT hTimer%<br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;&nbsp;&nbsp;IF KAddSomeExtraIoSignalB%<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOSIGNAL :IOSIGNAL // this one is 
        crazee!!! <br>
&nbsp;&nbsp;&nbsp;&nbsp;ENDIF<br>
&nbsp;&nbsp;ENDIF // end of async status checks<br>
        ENDWH<br>
        // put stray signals back again<br>
        WHILE StraySignalCount%&gt;0<br>
&nbsp;&nbsp;IOSIGNAL<br>
&nbsp;&nbsp;StraySignalCount%=StraySignalCount%-1<br>
        ENDWH<br>
        Info:(&quot;Finished&quot;)<br>
      ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC EventKeyProcess:(aKeyType&amp;,aKeyMod&amp;,aKeyScan&amp;)<br>
        Message:(&quot;Key &quot;+HEX$(aKeyType&amp;)+&quot; &quot;+HEX$(aKeyMod&amp;))<br>
        ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC EventPenProcess:(aPtrWID&amp;,aPtrType&amp;,aPtrX&amp;,aPtrY&amp;)<br>
        Message:(&quot;Pen &quot;+GEN$(aPtrWID&amp;,2)+&quot; &quot;+GEN$(aPtrX&amp;,3)+&quot; 
        &quot;+GEN$(aPtrY&amp;,3))<br>
        ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC TimeOutProcess:<br>
        Message:(&quot;Time out!&quot;)<br>
        ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC ___standard_stuff: 
        :ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC Info:(aText$)<br>
        InfoDialogue:(aText$,&quot;&quot;,&quot;&quot;)<br>
        ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC InfoDialogue:(aTitle$,aLine1$,aLine2$)<br>
        LOCAL Title$(KMaxStringLen%),Text$(KMaxStringLen%)<br>
        LOCAL choice%<br>
        IF aTitle$=&quot;Error&quot;<br>
        &nbsp;&nbsp;dINIT &quot;Error&quot;<br>
        &nbsp;&nbsp;dTEXT &quot;&quot;,ERRX$,KdTextCentre%<br>
        &nbsp;&nbsp;dTEXT &quot;&quot;,ERR$(ERR),KdTextCentre%<br>
        &nbsp;&nbsp;GOTO LBL_Dialog::<br>
        ELSEIF aTitle$=&quot;&quot;<br>
        &nbsp;&nbsp;Title$=&quot;Note&quot;<br>
        ELSE<br>
        &nbsp;&nbsp;Title$=aTitle$<br>
        ENDIF<br>
        Text$=aLine1$<br>
        IF aLine2$&lt;&gt;&quot;&quot;<br>
        &nbsp;&nbsp;Text$=Text$+NewLine$:+aLine2$<br>
        ENDIF<br>
        dINIT Title$<br>
        IF Text$&lt;&gt;&quot;&quot;<br>
        &nbsp;&nbsp;dTEXT &quot;&quot;,Text$<br>
        ENDIF<br>
        LBL_Dialog::<br>
        dBUTTONS &quot;Close&quot;,KKeyEnter%<br>
        LOCK ON :choice%=DIALOG :LOCK OFF<br>
        ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC NewLine$:<br>
        IF KSymbianOsVersion$=&quot;v5/Eikon&quot;<br>
        &nbsp;&nbsp;RETURN CHR$($0a) // ASCII<br>
        ELSE<br>
        &nbsp;&nbsp;RETURN CHR$(KLineFeed&amp;) // Unicode<br>
        ENDIF <br>
        ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC GetMachineType&amp;:<br>
        LOCAL value&amp;,return&amp;<br>
        value&amp;=0<br>
        return&amp;=SyGetHAL&amp;:(KSyMachineUID&amp;,value&amp;)<br>
        RETURN value&amp;<br>
        ENDP</font></p>
      <p><font face="Courier New, Courier, mono" size="-1">PROC GetMachineName$:<br>
        LOCAL value&amp;<br>
        IF KSymbianOsVersion$=&quot;v5/Eikon&quot;<br>
        &nbsp;&nbsp;RETURN MachineName$:<br>
        ENDIF<br>
        value&amp;=GetMachineType&amp;:<br>
        IF value&amp;=&amp;10005f62 // KSyMachineUid_Win32Emulator&amp;<br>
        &nbsp;&nbsp;RETURN &quot;Win32 ER6 Emulator&quot;<br>
        ELSEIF value&amp;=&amp;10005e33 // KSyMachineUid_Linda&amp;<br>
        &nbsp;&nbsp;RETURN &quot;Nokia 9200 Series&quot;<br>
        ELSEIF value&amp;=&amp;1000118a // KSyMachineUid_Series5mx&amp;<br>
        &nbsp;&nbsp;RETURN &quot;Psion Series 5mx&quot;<br>
        ELSE<br>
        &nbsp;&nbsp;RETURN &quot;unknown&quot;<br>
        ENDIF<br>
        ENDP</font></p>    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0029"></a></b></font></b><font color="#000080">dpNote 
      0029</font></b><font color="#000080"><br>
      <br>
      1 June 2003<br>
      <br>
      v6 Series 60
      <br>
      v6
      Series 80 R1 </font></font></td>
    <td width="700"> 
      <p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Key 
        event codes for Series 60 phones<br>
        <br>
      </font></b></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">Compared 
        to OPL for v6.0 Series 80, your </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">Const.oph</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        for Series 60 development will need some additional key event codes.</font> 
        <font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">A 
        few existing ones also deserve some additional comments.<br>
        <br>
        </font><font face="Courier New, Courier, mono" size="-1">// Key constants (for 
        32-bit keywords like GETEVENT32)<br>
        CONST K32BitKeywordLimit&amp;=&amp;f000<br>
        <br>
        CONST KKeyPageLeft&amp;=&amp;f802&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// WINS 
        only<br>
        CONST KKeyPageRight&amp;=&amp;f803&nbsp;&nbsp;&nbsp;&nbsp;// WINS only<br>
        CONST KKeyPageUp&amp;=&amp;f804&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        WINS only<br>
        CONST KKeyPageDown&amp;=&amp;f805&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// WINS 
        only<br>
        CONST KKeyEdit&amp;=&amp;f806&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 60 only<br>
        CONST KKeyLeftArrow&amp;=&amp;f807&nbsp;&nbsp;&nbsp;&nbsp;// Series 80 
        and 60<br>
        CONST KKeyRightArrow&amp;=&amp;f808&nbsp;&nbsp;&nbsp;// Series 80 and 
        60<br>
        CONST KKeyUpArrow&amp;=&amp;f809&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 80 and 60<br>
        CONST KKeyDownArrow&amp;=&amp;f80a&nbsp;&nbsp;&nbsp;&nbsp;// Series 80 
        and 60<br>
        // For the command button array<br>
        CONST KKeyCBA1&amp;=&amp;f842&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 80 and 60 (Left CBA)<br>
        CONST KKeyCBA2&amp;=&amp;f843&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 80 and 60 (Right CBA)<br>
        CONST KKeyCBA3&amp;=&amp;f844&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 80 and WINS<br>
        CONST KKeyCBA4&amp;=&amp;f845&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 80 and 60 (Select CBA)<br>
        // Special keys<br>
        CONST KKeySidebarMenu&amp;=&amp;f700 &nbsp;// WINS configured as in <b><font face="Arial, Helvetica, sans-serif" color="#000080"><a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0010">dpNote 
        0010</a></font></b> only<br>
        CONST KKeyZoomIn&amp;=&amp;f703&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        WINS only<br>
        CONST KKeyZoomOut&amp;=&amp;f704&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        WINS only<br>
        CONST KKeyMenu&amp;=&amp;f836&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 80 and WINS<br>
        CONST KKeyHelp&amp;=&amp;f83a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 80 and WINS<br>
        CONST KKeyApplications&amp;=&amp;f852&nbsp;// Series 60 only<br>
        CONST KKeySend&amp;=&amp;f862&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 60 only<br>
        CONST KKeyEndSend&amp;=&amp;f863&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
        Series 60 only<br>
        CONST KKeyBrightness&amp;=&amp;f864&nbsp;&nbsp;&nbsp;// Series 80 only<br>
        <br>
        // the Clear-key or [C]-key is actually Unicode Backspace<br>
        CONST KKeyBackspace&amp;=&amp;0008&nbsp;&nbsp;&nbsp;&nbsp;// Series 80 
        and 60 (Clear)<br>
        CONST KKeyClear&amp;=KKeyBackspace&amp;<br>
        <br>
        // The numeric keys including '*' and '#' follow Unicode values just like<br>
        // in Series 80 phones<br>
        CONST KKeyHash&amp;=&amp;0023<br>
        CONST KKeyNumberSign&amp;=KKeyHash&amp;<br>
        CONST KKeyStar&amp;=&amp;002a<br>
        CONST KKeyAsterisk&amp;=KKeyStar&amp;<br>
        CONST KKey_0&amp;=&amp;0030<br>
        CONST KKey_1&amp;=&amp;0031</font><font size="-1"><br>
        <font face="Courier New, Courier, mono">CONST KKey_2&amp;=&amp;0032</font><br>
        <font face="Courier New, Courier, mono">CONST KKey_3&amp;=&amp;0033</font><br>
        <font face="Courier New, Courier, mono">CONST KKey_4&amp;=&amp;0034</font><br>
        <font face="Courier New, Courier, mono">CONST KKey_5&amp;=&amp;0035</font><br>
        <font face="Courier New, Courier, mono">CONST KKey_6&amp;=&amp;0036</font><br>
        <font face="Courier New, Courier, mono">CONST KKey_7&amp;=&amp;0037<br>
        CONST KKey_8&amp;=&amp;0038<br>
        CONST KKey_9&amp;=&amp;0039<br>
        <br>
        </font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1">Take 
        note of the consistent use of </font><font face="Arial, Helvetica, sans-serif" size="-1"><font face="Courier New, Courier, mono">KKeyCBA4&amp;</font></font><font face="Arial, Helvetica, sans-serif" color="#000080" size="-1"> 
        as the Select-key for both Series 60 and Series 80 usage and style guide.<br>
        <i><br>
        Disclaimer: At the time of writing, OPL for Series 60 has reached v0.25 
        Alpha. With the continued development of OPL for Series 60 phones additions 
        and amendments will likely be made to this dpNote. Most likely, for instance, 
        in the future a Series 60 WINS console will be able to simulate additional 
        Series 60 keypresses.</i><br>
        </font></p>    </td>
  </tr>
  <tr valign="top">
    <td bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><b><font color="#000080"><b><a name="dpNote0030" id="dpNote0030"></a></b></font></b><font color="#000080">dpNote 
    0030</font></b><br>
    <font color="#000080"><br>
    14 May 2007<br>
    <br>
    All OPL versions</font></font> </td>
    <td><p><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Returning more than one value<br>
        <br>
      </font></b><font color="#000080">Yes, it <strong>is </strong>possible to return more than one value from a procedure. The technique is used in numerous places in dpNotes. Let's summarise it here.<br>
        <br>
        1. When calling a procedure, pass all values by reference, i.e. pass their pointers, instead of by value.<br>
        2. The called procedure should be programmed to receive values passed by reference and convert them into values.<br>
        3. Before leaving the procedure, the values passed by reference need to be stored back to their original pointers.<br>
        <br>
        As noted in <a href="http://web.archive.org/web/20080323085741/http://opldev.broeze.eu/dpNotes/#dpNote0012">dpNote 0012</a>, we use the &quot;_'&quot; to denote a pointer to a value passed by reference. <br>
        <br>
        </font><font size="-1"><font face="Courier New, Courier, mono">PROC ProcedureWithSeveralReturnValues:(_Byte&amp;,_Short&amp;,_Long&amp;,_Float&amp;,_String&amp;)<br>
        LOCAL Byte%,Short%,Long&amp;,FloatF,String$(KMaxStringLen%)<br>
        // load in BYREF values<br>
        Byte%=PEEKB(_Byte&amp;)<br>
        Short%=PEEKW(_Short&amp;)<br>
        Long&amp;+PEEKL(_Long&amp;)<br>
        FloatF=PEEKF(_Float&amp;)</font></font></font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Courier New, Courier, mono"><br>
        String$=PEEK$(_String&amp;)<br>
        // do something with these values<br>
        Byte%=Byte%*2<br>
        Short%=Short%/2+Byte%<br> 
        Long&amp;=Long&amp;/2+Short%<br>
        FloatF=FloatF+Long&amp;/1.5<br>
        String$=String$+GEN$(Float,6)<br>
        // return BYREF values<br>
        POKEB _Byte&amp;,Byte%<br>
        POKEW _Short&amp;,Short%<br>
        POKEL _Long&amp;,Long&amp;<br>
        POKEF _Float&amp;,FloatF<br>
        POKE$ _String&amp;,String$ <br>
        RETURN<br>
        <br>
        PROC CallingProcedure:<br>
        LOCAL Byte%,Short%,Long&amp;,FloatF,String$(KMaxStringLen%) <br>
        Byte%=$04<br>
        Short%=$0100<br>
        Long&amp;=&amp;00100000<br>
        FloatF=100.45<br>
        String$=&quot;Result: &quot;<br> 
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Courier New, Courier, mono">ProcedureWithSeveralReturnValues:(ADDR(Byte%),ADDR(Short%),ADDR(Long&amp;),ADDR(FloatF),ADDR(String$))</font></font></font><font face="Courier New, Courier, mono"><br>
        PRINT Byte%<br>
        PRINT Short%<br>
        PRINT Long&amp;<br>
        PRINT FloatF<br>
        PRINT String$
        <br>
        ENDP
        <br>
        <br>
        <font color="#000080" face="Arial, Helvetica, sans-serif">Having now shown how this works, it would have been much nicer if it had been possible to use the '@'  character for obtaining pointers rather than </font>ADDR().<font color="000080" face="Arial, Helvetica, sans-serif"> Then we could have written:</font><br>
        <br>
        </font><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Arial, Helvetica, sans-serif" size="-1"><font size="-1"><font face="Courier New, Courier, mono">ProcedureWithSeveralReturnValues:(@Byte%,@Short%,@Long&amp;,@FloatF,@String$)</font></font></font></font></font>        </font></font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td width="97" rowspan="3" bgcolor="#FFFFCC"><font face="Arial, Helvetica, sans-serif" size="-1"><b><font color="#000080">Links 
      to other OPL developer resources</font></b></font></td>
    <td width="700"><font size="-1"><a href="http://web.archive.org/web/20080323085741/http://www.opl32.com/Menu_Fiches.htm"><font face="Arial, Helvetica, sans-serif">http://www.opl32.com/Menu_Fiches.htm 
      </font></a><font face="Arial, Helvetica, sans-serif">- even if you cannot 
      read French, this site offers a number of very good OPL for Symbian OS v5 
      related notes. It is not updated very often though.</font></font></td>
  </tr>
    <td bgcolor="#dddddd" width="700"><font size="-1" face="Arial"><a href="http://web.archive.org/web/20080323085741/http://www.allaboutopl.com/wiki/OPLWikiHome">http://www.allaboutopl.com/wiki/OPLWikiHome</a></font><font size="-1"> 
    - <font face="Arial">this site has the purpose of being the central Documents 
    and Reference site for OPL, in particular for Symbian OS v6.0 and later. It 
    is a Wiki site, meaning that anyone can register and contribute to the OPL 
    projects.</font></font></td>
  <tr> 
    <td bgcolor="#dddddd" colspan="2"> 
      <p>&nbsp;</p>    </td>
  </tr>
</table>
</body>
</html>




<!--
     FILE ARCHIVED ON 8:57:41 Mar 23, 2008 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 14:24:26 Nov 1, 2012.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
